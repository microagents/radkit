{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Radkit - Rust Agent Development Kit"},{"location":"#what-is-radkit","title":"What is Radkit?","text":"<p>Radkit is an agent framework for building AI agents in Rust. It provides comprehensive support for the A2A (Agent-to-Agent) Protocol, enabling seamless agent interoperability with zero conversion overhead.</p> <p>Built with enterprise-grade architecture, Radkit offers: - \ud83d\ude80 A2A-Native Design: Unlike other agent frameworks (Autogen, CrewAI, Langchain, ADK) where a2a is a secondary layer, Radkit is built from the ground up to support the protocol natively. - \ud83e\udd16 Multi-Provider LLM Support: Anthropic Claude, Google Gemini, and more - \ud83d\udd27 Advanced Tool System: Function calling with built-in task management tools</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>[dependencies]\nradkit = \"0.0.1\"\nfutures = \"0.3.31\"\ntokio = \"1.47.1\"\nuuid = \"1.18.0\"\ndotenvy = \"0.15.7\"\n</code></pre> <p>Create a <code>.env</code> file with your Anthropic API key:</p> <pre><code>ANTHROPIC_API_KEY=\"YOUR_API_KEY\"\n</code></pre> <p>Then, create an agent and send a message:</p> <pre><code>use futures::StreamExt;\nuse radkit::a2a::{\n    Message, MessageRole, MessageSendParams, Part, SendStreamingMessageResult, TaskState,\n};\nuse radkit::agents::{Agent, AgentConfig};\nuse radkit::models::AnthropicLlm;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load environment variables from .env file.\n    dotenvy::dotenv()?;\n\n    // Create an LLM provider (supports Anthropic, Gemini, and Mock providers)\n    let llm = AnthropicLlm::new(\n        \"claude-3-5-sonnet-20241022\".to_string(),\n        std::env::var(\"ANTHROPIC_API_KEY\")?,\n    );\n\n    // Create an agent with built-in task management tools\n    let agent = Agent::builder(\n        \"You are a helpful research assistant. When working on tasks,\n        always use update_status to indicate your progress (e.g., 'working' when processing, 'completed' when done.\n        When you produce any results or findings, save them using save_artifact so they can be retrieved later.\",\n        llm,\n    )\n        .with_config(AgentConfig::default().with_max_iterations(10))\n        .with_builtin_task_tools() // Enables update_status and save_artifact tools\n        .build();\n\n    // User simply asks for research - no mention of tools\n    let message = Message {\n        kind: \"message\".to_string(),\n        message_id: uuid::Uuid::new_v4().to_string(),\n        role: MessageRole::User,\n        parts: vec![Part::Text {\n            text: \"Can you research the Fibonacci sequence and create a \\\n                   summary of its properties and applications?\"\n                .to_string(),\n            metadata: None,\n        }],\n        context_id: None, // New session will be created\n        task_id: None,    // New task will be created\n        reference_task_ids: Vec::new(),\n        extensions: Vec::new(),\n        metadata: None,\n    };\n\n    // Stream the execution to capture real-time A2A protocol events\n    let mut execution = agent\n        .send_streaming_message(\n            \"my_app\".to_string(),\n            \"user123\".to_string(),\n            MessageSendParams {\n                message,\n                configuration: None,\n                metadata: None,\n            },\n        )\n        .await?;\n\n    let mut status_events = 0;\n    let mut artifact_events = 0;\n    let mut final_task = None;\n\n    // Process streaming results and capture A2A protocol events\n    while let Some(event) = execution.a2a_stream.next().await {\n        match event {\n            SendStreamingMessageResult::TaskStatusUpdate(status_event) =&gt; {\n                status_events += 1;\n                println!(\"\ud83d\udcca Status Update: {:?}\", status_event.status.state);\n\n                if status_event.status.message.is_some() {\n                    println!(\n                        \"  Message: {:?}\",\n                        status_event.status.message.as_ref().unwrap()\n                    );\n                }\n            }\n            SendStreamingMessageResult::TaskArtifactUpdate(artifact_event) =&gt; {\n                artifact_events += 1;\n                println!(\"\ud83d\udcbe Artifact Saved: {:?}\", artifact_event.artifact.name);\n            }\n            SendStreamingMessageResult::Task(task) =&gt; {\n                println!(\"\u2705 Task Completed: {}\", task.id);\n                final_task = Some(task);\n                break;\n            }\n            _ =&gt; {} // Handle other events as needed\n        }\n    }\n\n    // Examine the final task state\n    if let Some(task) = final_task {\n        println!(\"\\n\ud83d\udcc8 Final Results:\");\n        println!(\"  Task State: {:?}\", task.status.state);\n        println!(\"  Messages: {}\", task.history.len());\n        println!(\"  Artifacts: {}\", task.artifacts.len());\n\n        // Check the saved artifact content\n        if let Some(artifact) = task.artifacts.first() {\n            if let Some(Part::Text { text, .. }) = artifact.parts.first() {\n                println!(\n                    \"  Artifact Content Preview: {}\",\n                    &amp;text[..text.len().min(200)]\n                );\n            }\n        }\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#a2a-protocol-native","title":"A2A Protocol Native","text":"<ul> <li>Protocol Methods: Implements <code>message/send</code>, <code>message/stream</code>, <code>tasks/get</code></li> <li>Event Streaming: Tools can generate compliant <code>TaskStatusUpdate</code> and <code>TaskArtifactUpdate</code> events</li> </ul>"},{"location":"#comprehensive-task-system","title":"Comprehensive Task System","text":"<ul> <li>Follows Task Lifecycle: <code>Submitted \u2192 Working \u2192 [InputRequired/AuthRequired] \u2192 Completed/Failed</code></li> <li>Atomic Operations: Thread-safe message, artifact, and status updates</li> <li>A2A Events: Automatic generation of protocol-compliant events</li> <li>Built-in Tools: <code>update_status</code> and <code>save_artifact</code> with event emission</li> </ul>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<p> Getting Started Tools Guide Task Guide Session Guide </p>"},{"location":"#development-status","title":"Development Status","text":"<p>Current Version: 0.1.0 (Work in Progress - Major Architecture Complete)</p> <p>\u2705 Completed Features: - A2A Protocol core implementation with native types - Multi-provider LLM support (Anthropic Claude, Google Gemini) - Task lifecycle management with A2A event streaming - Comprehensive tool system with built-in A2A tools - Secure ToolContext with capability-based access control - State management with three-tier state isolation (app/user/session)</p> <p>\ud83d\udea7 Coming Soon: - A2A Server mode (HTTP/gRPC endpoints for agent interoperability) - A2A Client mode (call other A2A agents via function calling) - MCP (Model Context Protocol) tools integration - OpenAPI tool generation and validation - Production persistent storage backends (PostgreSQL, Redis) - WebSocket streaming support for real-time clients</p>"},{"location":"#license","title":"License","text":"<p>Radkit is licensed under the Apache 2.0 License. See LICENSE for details.</p>"},{"location":"axum-server/","title":"Axum Server for A2A Protocol","text":"<p>The <code>radkit-axum</code> crate provides a complete HTTP server implementation that exposes Radkit agents as A2A (Agent-to-Agent) protocol compliant endpoints. This enables your agents to communicate with other A2A-compatible agents and systems over HTTP.</p>"},{"location":"axum-server/#overview","title":"Overview","text":"<p>The A2A protocol is an open standard for AI agent interoperability. By running your Radkit agent with the Axum server, you get:</p> <ul> <li>Full A2A compliance - All protocol methods implemented</li> <li>JSON-RPC 2.0 transport - Standard request/response format</li> <li>Server-Sent Events (SSE) - Real-time streaming updates</li> <li>Agent Card discovery - Automatic capability advertisement</li> <li>Flexible authentication - Pluggable auth system</li> <li>Production ready - Built on Axum, Tower, and Hyper</li> </ul>"},{"location":"axum-server/#agent-architecture-design","title":"Agent Architecture Design","text":"<p>Radkit agents are designed as multi-tenant systems where every method requires: - <code>app_name</code> - Application/tenant identifier - <code>user_id</code> - User identifier within that application</p> <p>This enables a single agent instance to serve multiple applications and users while maintaining proper isolation of sessions, tasks, and state. The Axum server's authentication system maps HTTP requests to these required parameters.</p>"},{"location":"axum-server/#quick-start","title":"Quick Start","text":""},{"location":"axum-server/#installation","title":"Installation","text":"<p>Add these dependencies to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nradkit = \"0.1\"\nradkit-axum = \"0.1\"\naxum = \"0.7\"\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre>"},{"location":"axum-server/#basic-server","title":"Basic Server","text":"<pre><code>use radkit::agents::Agent;\nuse radkit::models::MockLlm;\nuse radkit_axum::A2AServer;\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create your agent with AgentCard configuration\n    let llm = Arc::new(MockLlm::new(\"gpt-4\".to_string()));\n    let agent = Agent::builder(\n        \"You are a helpful AI assistant.\",\n        MockLlm::new(\"gpt-4\".to_string()),\n    )\n    .with_card(|c| c\n        .with_name(\"My AI Agent\")\n        .with_description(\"A helpful assistant\")\n        .with_version(\"1.0.0\")\n        .with_url(\"http://localhost:3000\")\n        .with_streaming(true)\n    )\n    .with_builtin_task_tools()\n    .build();\n\n    // Create and run A2A server\n    let server = A2AServer::builder(agent)\n        .build();\n\n    println!(\"Server starting on http://localhost:3000\");\n    server.serve(\"0.0.0.0:3000\").await?;\n    Ok(())\n}\n</code></pre>"},{"location":"axum-server/#testing-your-server","title":"Testing Your Server","text":"<p>Once running, test with curl:</p> <pre><code># Get agent capabilities\ncurl http://localhost:3000/.well-known/agent-card.json\n\n# Send a message (using default auth headers)\ncurl -X POST http://localhost:3000/message/send \\\n  -H 'X-App-Name: myapp' \\\n  -H 'X-User-Id: user1' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"message/send\",\n    \"params\": {\n      \"message\": {\n        \"role\": \"user\",\n        \"parts\": [{\"kind\": \"text\", \"text\": \"Hello!\"}]\n      }\n    },\n    \"id\": 1\n  }'\n</code></pre>"},{"location":"axum-server/#authentication-with-authextractor","title":"Authentication with AuthExtractor","text":"<p>Important: All Radkit agent methods require <code>app_name</code> and <code>user_id</code> parameters. The <code>AuthExtractor</code> trait allows you to implement custom authentication strategies to extract these values from HTTP requests.</p>"},{"location":"axum-server/#default-authentication-behavior","title":"Default Authentication Behavior","text":"<p>If no <code>AuthExtractor</code> is provided, the server uses a default implementation that: - Extracts <code>app_name</code> from the <code>X-App-Name</code> header (defaults to <code>\"default\"</code>) - Extracts <code>user_id</code> from the <code>X-User-Id</code> header (defaults to <code>\"anonymous\"</code>)</p> <pre><code># Using default authentication\ncurl -X POST http://localhost:3000/message/send \\\n  -H 'X-App-Name: myapp' \\\n  -H 'X-User-Id: user123' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"message/send\",\"params\":{...},\"id\":1}'\n\n# Without headers (uses defaults)\ncurl -X POST http://localhost:3000/message/send \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"message/send\",\"params\":{...},\"id\":1}'\n# app_name=\"default\", user_id=\"anonymous\"\n</code></pre>"},{"location":"axum-server/#custom-authentication","title":"Custom Authentication","text":"<p>The <code>AuthExtractor</code> trait allows you to implement custom authentication strategies. The server extracts <code>app_name</code> and <code>user_id</code> from HTTP requests, which are then passed to your Radkit agent methods.</p>"},{"location":"axum-server/#authextractor-trait","title":"AuthExtractor Trait","text":"<p>The core responsibility of any <code>AuthExtractor</code> is to map HTTP requests to the <code>app_name</code> and <code>user_id</code> that Radkit agent methods require:</p> <pre><code>#[async_trait]\npub trait AuthExtractor: Send + Sync + 'static {\n    /// Extract authentication context from request parts\n    /// Must provide app_name and user_id for multi-tenant agent operation\n    async fn extract(&amp;self, parts: &amp;mut Parts) -&gt; Result&lt;AuthContext, AuthError&gt;;\n}\n\npub struct AuthContext {\n    pub app_name: String,  // Tenant/application identifier (REQUIRED)\n    pub user_id: String,   // User identifier within app (REQUIRED)\n    pub metadata: Option&lt;serde_json::Value&gt;, // Optional additional data\n}\n</code></pre> <p>Key Point: Every HTTP request must be mapped to an <code>app_name</code> and <code>user_id</code>. This is the bridge between HTTP authentication (tokens, keys, etc.) and Radkit's multi-tenant agent architecture.</p>"},{"location":"axum-server/#example-api-key-authentication","title":"Example: API Key Authentication","text":"<pre><code>use radkit_axum::{AuthContext, AuthExtractor, async_trait};\n\nstruct ApiKeyAuth {\n    valid_keys: Vec&lt;String&gt;,\n}\n\n#[async_trait]\nimpl AuthExtractor for ApiKeyAuth {\n    async fn extract(&amp;self, parts: &amp;mut axum::http::request::Parts) \n        -&gt; Result&lt;AuthContext, radkit_axum::auth::AuthError&gt; {\n\n        // Extract API key from Authorization header\n        let api_key = parts\n            .headers\n            .get(\"Authorization\")\n            .and_then(|v| v.to_str().ok())\n            .and_then(|v| v.strip_prefix(\"Bearer \"))\n            .ok_or(radkit_axum::auth::AuthError::MissingCredentials)?;\n\n        // Validate API key\n        if !self.valid_keys.contains(&amp;api_key.to_string()) {\n            return Err(radkit_axum::auth::AuthError::InvalidToken);\n        }\n\n        // Map API key to app_name and user_id\n        let (app_name, user_id) = match api_key {\n            \"test-key-1\" =&gt; (\"app1\", \"user1\"),\n            \"test-key-2\" =&gt; (\"app2\", \"user2\"),\n            _ =&gt; return Err(radkit_axum::auth::AuthError::InvalidToken),\n        };\n\n        Ok(AuthContext {\n            app_name: app_name.to_string(),\n            user_id: user_id.to_string(),\n            metadata: None,\n        })\n    }\n}\n\n// Use it in your server\nlet server = A2AServer::builder(agent)\n    .with_auth(ApiKeyAuth {\n        valid_keys: vec![\"test-key-1\".to_string(), \"test-key-2\".to_string()],\n    })\n    .build();\n</code></pre>"},{"location":"axum-server/#example-jwt-authentication","title":"Example: JWT Authentication","text":"<pre><code>struct JwtAuth {\n    secret: String,\n}\n\n#[async_trait]\nimpl AuthExtractor for JwtAuth {\n    async fn extract(&amp;self, parts: &amp;mut axum::http::request::Parts) \n        -&gt; Result&lt;AuthContext, radkit_axum::auth::AuthError&gt; {\n\n        // Extract JWT from Authorization header\n        let token = parts\n            .headers\n            .get(\"Authorization\")\n            .and_then(|v| v.to_str().ok())\n            .and_then(|v| v.strip_prefix(\"Bearer \"))\n            .ok_or(radkit_axum::auth::AuthError::MissingCredentials)?;\n\n        // Decode and verify JWT (use a proper JWT library like `jsonwebtoken`)\n        let claims = decode_jwt(token, &amp;self.secret)?;\n\n        Ok(AuthContext {\n            app_name: claims.tenant,\n            user_id: claims.sub,\n            metadata: Some(serde_json::json!({\n                \"exp\": claims.exp,\n                \"iat\": claims.iat,\n            })),\n        })\n    }\n}\n</code></pre>"},{"location":"axum-server/#common-authentication-patterns","title":"Common Authentication Patterns","text":"<ol> <li>API Keys: Simple bearer tokens mapped to app/user</li> <li>JWT: Signed tokens with claims for tenant and user</li> <li>OAuth: OAuth2/OIDC tokens validated against provider</li> <li>Database lookup: API key -&gt; database query for user info</li> <li>Service-to-service: mTLS certificates or shared secrets</li> </ol>"},{"location":"axum-server/#a2a-protocol-endpoints","title":"A2A Protocol Endpoints","text":"<p>Your server automatically exposes these A2A-compliant endpoints:</p>"},{"location":"axum-server/#core-protocol-methods","title":"Core Protocol Methods","text":"<ul> <li><code>POST /message/send</code> - Send messages to the agent (JSON-RPC)</li> <li><code>POST /message/stream</code> - Send messages with streaming responses (SSE)</li> <li><code>POST /tasks/get</code> - Get task status and results</li> <li><code>POST /tasks/cancel</code> - Cancel running tasks (not yet implemented)</li> <li><code>POST /tasks/resubscribe</code> - Resubscribe to task updates (not yet implemented)</li> </ul>"},{"location":"axum-server/#discovery-health","title":"Discovery &amp; Health","text":"<ul> <li><code>GET /.well-known/agent-card.json</code> - Agent capability discovery (public)</li> <li><code>POST /agent/getAuthenticatedExtendedCard</code> - Extended card for authenticated users</li> <li><code>GET /health</code> - Health check endpoint</li> </ul>"},{"location":"axum-server/#request-format-json-rpc-20","title":"Request Format (JSON-RPC 2.0)","text":"<p>All protocol methods use JSON-RPC 2.0 format:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"kind\": \"text\", \"text\": \"Hello!\"}]\n    }\n  },\n  \"id\": 1\n}\n</code></pre>"},{"location":"axum-server/#streaming-server-sent-events","title":"Streaming (Server-Sent Events)","text":"<p>The <code>/message/stream</code> endpoint returns SSE events:</p> <pre><code>curl -X POST http://localhost:3000/message/stream \\\n  -H 'Authorization: Bearer your-token' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"message/stream\",\"params\":{...},\"id\":1}' \\\n  --no-buffer\n</code></pre> <p>Events come as: <pre><code>data: {\"jsonrpc\":\"2.0\",\"result\":{\"kind\":\"task-status-update\",...},\"id\":1}\n\ndata: {\"jsonrpc\":\"2.0\",\"result\":{\"kind\":\"task-completed\",...},\"id\":1}\n</code></pre></p>"},{"location":"axum-server/#agent-card-configuration","title":"Agent Card Configuration","text":"<p>Agent cards describe your agent's capabilities and are served at <code>/.well-known/agent-card.json</code>. The AgentCard is now integrated directly into the Agent and can be configured using the fluent builder API:</p>"},{"location":"axum-server/#basic-agent-card-configuration","title":"Basic Agent Card Configuration","text":"<pre><code>let agent = Agent::builder(\n        \"You are a helpful AI assistant.\",\n        llm,\n    )\n    .with_card(|c| c\n        .with_name(\"My AI Agent\")\n        .with_description(\"A powerful AI assistant\")\n        .with_version(\"1.0.0\")\n        .with_url(\"https://my-agent.example.com\")\n        .with_streaming(true)\n        .with_push_notifications(false)\n        .with_state_transition_history(false)\n        .add_skill_with(\"general-help\", \"General Assistance\", |skill| {\n            skill.with_description(\"Helps with questions and tasks\")\n                .add_tag(\"general\")\n                .add_tag(\"help\")\n                .add_example(\"How do I...?\")\n        })\n        .with_security_schemes(std::collections::HashMap::from([\n            (\"bearerAuth\".to_string(), a2a_types::SecurityScheme::Http(\n                a2a_types::HTTPAuthSecurityScheme {\n                    scheme_type: \"http\".to_string(),\n                    scheme: \"bearer\".to_string(),\n                    bearer_format: Some(\"JWT\".to_string()),\n                    description: Some(\"JWT authentication\".to_string()),\n                }\n            )),\n        ]))\n});\n\nlet server = A2AServer::builder(agent)\n    .build();\n</code></pre>"},{"location":"axum-server/#server-specific-card-configuration","title":"Server-Specific Card Configuration","text":"<p>You can also override AgentCard settings specifically for the server (useful for setting production URLs):</p> <pre><code>let server = A2AServer::builder(agent)\n    .with_agent_card_config(|card| {\n        card.with_url(\"https://production-api.example.com\")\n            .with_documentation_url(\"https://docs.example.com\")\n    })\n    .build();\n</code></pre>"},{"location":"axum-server/#default-behavior","title":"Default Behavior","text":"<p>If no AgentCard configuration is provided: - Agent name and description are used from the Agent - Version defaults to empty string (server sets \"0.1.0\" if empty) - URL defaults to empty string (server sets \"http://localhost:3000\" if empty) - Streaming is automatically enabled for servers - Basic capabilities are set with sensible defaults</p>"},{"location":"axum-server/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"axum-server/#custom-middleware","title":"Custom Middleware","text":"<p>You can add custom Axum middleware:</p> <pre><code>let server = A2AServer::builder(agent)\n    .with_auth(MyAuth)\n    .with_agent_card_config(|card| {\n        card.with_url(\"https://api.example.com\")\n            .with_version(\"2.0.0\")\n    })\n    .build();\n\nlet app = server.into_router()\n    .layer(tower_http::trace::TraceLayer::new_for_http())\n    .layer(tower_http::cors::CorsLayer::permissive())\n    .layer(tower_http::timeout::TimeoutLayer::new(std::time::Duration::from_secs(30)));\n\naxum::serve(listener, app).await?;\n</code></pre>"},{"location":"axum-server/#custom-router-integration","title":"Custom Router Integration","text":"<p>Integrate with existing Axum applications:</p> <pre><code>let a2a_server = A2AServer::builder(agent).build();\nlet a2a_routes = a2a_server.into_router();\n\nlet app = Router::new()\n    .route(\"/\", get(|| async { \"Hello World!\" }))\n    .nest(\"/a2a\", a2a_routes)  // Mount A2A endpoints under /a2a\n    .route(\"/metrics\", get(metrics_handler));\n</code></pre>"},{"location":"axum-server/#production-deployment","title":"Production Deployment","text":""},{"location":"axum-server/#environment-variables","title":"Environment Variables","text":"<pre><code># Server configuration\nBIND_ADDRESS=0.0.0.0:3000\nLOG_LEVEL=info\n\n# Authentication\nJWT_SECRET=your-secret-key\nAPI_KEYS=key1,key2,key3\n\n# Agent configuration\nAGENT_NAME=\"Production Agent\"\nAGENT_VERSION=1.0.0\nOPENAI_API_KEY=your-openai-key\n</code></pre>"},{"location":"axum-server/#docker-example","title":"Docker Example","text":"<pre><code>FROM rust:1.75 as builder\nWORKDIR /app\nCOPY . .\nRUN cargo build --release\n\nFROM debian:bookworm-slim\nRUN apt-get update &amp;&amp; apt-get install -y ca-certificates &amp;&amp; rm -rf /var/lib/apt/lists/*\nCOPY --from=builder /app/target/release/my-agent /usr/local/bin/\nEXPOSE 3000\nCMD [\"my-agent\"]\n</code></pre>"},{"location":"axum-server/#health-checks","title":"Health Checks","text":"<pre><code># Docker health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:3000/health || exit 1\n\n# Kubernetes liveness probe\nlivenessProbe:\n  httpGet:\n    path: /health\n    port: 3000\n  initialDelaySeconds: 30\n  periodSeconds: 10\n</code></pre>"},{"location":"axum-server/#load-balancing","title":"Load Balancing","text":"<p>The server is stateless and can be load balanced. Session state is managed within individual agent instances, so sticky sessions are not required for basic operations.</p>"},{"location":"axum-server/#error-handling","title":"Error Handling","text":"<p>The server returns proper HTTP status codes and JSON-RPC error responses:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params: Missing required field\"\n  },\n  \"id\": 1\n}\n</code></pre> <p>Common error codes: - <code>-32700</code>: Parse error - <code>-32600</code>: Invalid request - <code>-32601</code>: Method not found - <code>-32602</code>: Invalid params - <code>-32603</code>: Internal error - <code>401</code>: Authentication required - <code>403</code>: Insufficient permissions</p>"},{"location":"axum-server/#complete-examples","title":"Complete Examples","text":"<p>See the <code>/examples</code> directory in the <code>radkit-axum</code> crate:</p> <ul> <li><code>basic_server.rs</code> - Simple API key authentication</li> <li><code>jwt_server.rs</code> - JWT-based authentication with full agent card</li> </ul> <p>Run examples:</p> <pre><code>cargo run --example basic_server\ncargo run --example jwt_server\n</code></pre>"},{"location":"axum-server/#a2a-protocol-resources","title":"A2A Protocol Resources","text":"<ul> <li>A2A Specification: https://a2a.dev/</li> <li>Agent Card Schema: Discovery format for agent capabilities</li> <li>JSON-RPC 2.0: https://www.jsonrpc.org/specification</li> <li>Server-Sent Events: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events</li> </ul> <p>The Radkit Axum server provides a complete, production-ready implementation of the A2A protocol, making your agents discoverable and interoperable with the broader AI agent ecosystem.</p>"},{"location":"getting-started/","title":"Getting Started with Radkit","text":"<p>This guide will help you get up and running with Radkit, the A2A-native agent development kit for Rust.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust: Version 1.70 or higher</li> <li>Cargo: Rust's package manager</li> <li>API Keys: For LLM providers (Anthropic Claude, Google Gemini)</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add these dependencies to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nradkit = \"0.0.1\"\nfutures = \"0.3.31\"\ntokio = \"1.47.1\"\nuuid = \"1.18.0\"\ndotenvy = \"0.15.7\"\n</code></pre>"},{"location":"getting-started/#setting-up-your-first-agent","title":"Setting Up Your First Agent","text":""},{"location":"getting-started/#step-1-environment-configuration","title":"Step 1: Environment Configuration","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code># For Anthropic Claude\nANTHROPIC_API_KEY=sk-ant-your-key-here\n\n# For Google Gemini\nGEMINI_API_KEY=your-gemini-key-here\n</code></pre>"},{"location":"getting-started/#step-2-basic-agent-creation","title":"Step 2: Basic Agent Creation","text":"<pre><code>use radkit::a2a::{Message, MessageRole, MessageSendParams, Part, SendMessageResult};\nuse radkit::agents::Agent;\nuse radkit::models::AnthropicLlm;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load environment variables\n    dotenvy::dotenv().ok();\n\n    // Create an LLM provider\n    let llm = AnthropicLlm::new(\n        \"claude-3-5-sonnet-20241022\".to_string(),\n        std::env::var(\"ANTHROPIC_API_KEY\")?,\n    );\n\n    // Create an agent (services are created automatically)\n    let agent = Agent::builder(\n        \"You are a knowledgeable and friendly assistant.\",\n        llm,\n    )\n    .with_card(|c| c\n        .with_name(\"MyFirstAgent\")\n        .with_description(\"A helpful AI assistant\")\n    )\n    .build();\n\n    println!(\"\u2705 Agent created successfully!\");\n\n    // Your agent is ready to use!\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/#step-3-sending-your-first-message","title":"Step 3: Sending Your First Message","text":"<pre><code>// Helper function to create a user message\nfn create_user_message(text: &amp;str) -&gt; Message {\n    Message {\n        kind: \"message\".to_string(),\n        message_id: uuid::Uuid::new_v4().to_string(),\n        role: MessageRole::User,\n        parts: vec![Part::Text {\n            text: text.to_string(),\n            metadata: None,\n        }],\n        context_id: None,  // Will create a new session\n        task_id: None,     // Will create a new task\n        reference_task_ids: Vec::new(),\n        extensions: Vec::new(),\n        metadata: None,\n    }\n}\n\n// Create message parameters\nlet params = MessageSendParams {\n    message: create_user_message(\"Hello! What can you help me with today?\"),\n    configuration: None,\n    metadata: None,\n};\n\n// Send the message (non-streaming)\nlet response = agent.send_message(\n    \"my_app\".to_string(),      // Application name\n    \"user123\".to_string(),     // User ID\n    params,\n).await?;\n\n// Process the response\nmatch response.result {\n    SendMessageResult::Task(task) =&gt; {\n        println!(\"\u2705 Task created: {}\", task.id);\n        println!(\"Context ID: {}\", task.context_id);\n        println!(\"Status: {:?}\", task.status.state);\n\n        // Get the agent's response\n        for message in &amp;task.history {\n            if message.role == MessageRole::Agent {\n                for part in &amp;message.parts {\n                    if let Part::Text { text, .. } = part {\n                        println!(\"Agent: {}\", text);\n                    }\n                }\n            }\n        }\n    }\n    SendMessageResult::Message(msg) =&gt; {\n        println!(\"Received direct message response\");\n    }\n}\n</code></pre>"},{"location":"getting-started/#understanding-core-concepts","title":"Understanding Core Concepts","text":""},{"location":"getting-started/#1-multi-tenancy","title":"1. Multi-Tenancy","text":"<p>Radkit provides built-in multi-tenant isolation:</p> <pre><code>// Each request requires app_name and user_id\nagent.send_message(\n    \"app_name\".to_string(),   // Isolates different applications\n    \"user_id\".to_string(),    // Isolates different users\n    params,\n).await?;\n</code></pre> <p>This ensures complete data isolation between different applications and users.</p>"},{"location":"getting-started/#2-tasks-and-sessions","title":"2. Tasks and Sessions","text":"<p>Every agent interaction creates or continues: - Task: A unit of work with history and artifacts - Session: A conversation context (maps to A2A contextId)</p> <pre><code>// Continue an existing conversation in the same session\nlet mut follow_up_message = create_user_message(\"Do you remember what we were talking about?\");\nfollow_up_message.context_id = Some(\"existing_context_id\".to_string());\n// task_id remains None to create a new task in the same session\n\nlet params = MessageSendParams {\n    message: follow_up_message,\n    configuration: None,\n    metadata: None,\n};\n\nlet response = agent.send_message(\"my_app\".to_string(), \"user123\".to_string(), params).await?;\n</code></pre>"},{"location":"getting-started/#how-conversations-are-built-from-session-events","title":"How Conversations are Built from Session Events","text":"<p>Key Architecture: Radkit builds conversations dynamically from <code>session.events</code> rather than storing static message history. This enables:</p> <ul> <li>Cross-Task Memory: Agents remember conversations across multiple tasks in the same session</li> <li>Event-Driven Conversation: All interactions (messages, tool calls, state changes) are stored as events</li> <li>A2A Context Mapping: Session ID directly maps to A2A <code>contextId</code> for protocol compliance</li> </ul> <pre><code>// Example: How the agent reconstructs conversation context\nasync fn create_llm_request(&amp;self, context: &amp;ExecutionContext) -&gt; LlmRequest {\n    // Get conversation from EventProcessor which reconstructs from session events\n    let content_messages = context.get_llm_conversation().await?;\n\n    // The LLM sees the ENTIRE conversation history reconstructed from events\n    LlmRequest {\n        messages: content_messages,     // All content from session events\n        current_task_id: context.task_id.clone(),\n        context_id: context.context_id.clone(),   // Maps to A2A contextId\n        system_instruction: Some(self.agent.instruction().to_string()),\n        config: GenerateContentConfig::default(),\n        toolset: self.agent.toolset().cloned(),\n        metadata: context.current_params.metadata.clone().unwrap_or_default(),\n    }\n}\n\n// SessionEvent to Content conversion preserves:\n// - User messages (SessionEventType::UserMessage)\n// - Agent responses (SessionEventType::AgentMessage)  \n// - Function calls and responses (ContentPart within messages)\n// - All metadata and context information\n</code></pre> <p>This means when you continue a conversation: 1. Same <code>context_id</code> = Agent remembers everything from previous tasks 2. New <code>context_id</code> = Fresh conversation with no memory 3. Events are the source of truth = No separate message storage needed</p>"},{"location":"getting-started/#3-built-in-tools","title":"3. Built-in Tools","text":"<p>Enable task management capabilities:</p> <pre><code>use radkit::agents::AgentConfig;\n\nlet config = AgentConfig::default().with_max_iterations(10);\n\nlet agent = Agent::builder(\n        \"You can update task status and save artifacts using built-in tools.\",\n        llm,\n    )\n    .with_card(|c| c\n        .with_name(\"builtin_agent\")\n        .with_description(\"Agent with built-in tools\")\n    )\n    .with_config(config)\n    .with_builtin_task_tools();  // Adds update_status and save_artifact tools\n    .build();\n\n// The agent can now use:\n// - update_status: Update task status (submitted, working, completed, failed, etc.)\n// - save_artifact: Save analysis results, files, or any generated content\n// These tools automatically emit A2A-compliant events\n</code></pre>"},{"location":"getting-started/#4-custom-function-tools","title":"4. Custom Function Tools","text":"<p>Create your own tools using <code>FunctionTool</code>:</p> <pre><code>use radkit::tools::{FunctionTool, ToolResult};\nuse serde_json::json;\n\n// Create a weather tool\nfn create_weather_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"get_weather\".to_string(),\n        \"Get the current weather for a location\".to_string(),\n        |args, _context| Box::pin(async move {\n            let location = args\n                .get(\"location\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"Unknown\");\n\n            let weather_data = json!({\n                \"location\": location,\n                \"temperature\": \"72\u00b0F\",\n                \"conditions\": \"Partly cloudy\",\n                \"humidity\": \"45%\"\n            });\n\n            ToolResult::success(weather_data)\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"The city and state, e.g. San Francisco, CA\"\n            }\n        },\n        \"required\": [\"location\"]\n    }))\n}\n\n// Example tool that uses ToolContext for state management\nfn create_preference_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"set_preference\".to_string(),\n        \"Set user preferences\".to_string(),\n        |args, context| Box::pin(async move {\n            let key = args\n                .get(\"key\")\n                .and_then(|v| v.as_str())\n                .unwrap_or_default();\n            let value = args\n                .get(\"value\")\n                .cloned()\n                .unwrap_or(json!(null));\n\n            // Use the ToolContext API for state management\n            match context.set_user_state(key.to_string(), value.clone()).await {\n                Ok(()) =&gt; ToolResult::success(json!({\n                    \"message\": format!(\"Set preference '{}' to: {}\", key, value)\n                })),\n                Err(e) =&gt; ToolResult::error(format!(\"Failed to set preference: {}\", e))\n            }\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The preference key to set\"\n            },\n            \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The preference value to set\"\n            }\n        },\n        \"required\": [\"key\", \"value\"]\n    }))\n}\n\n// Create a calculator tool\nfn create_calculator_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"calculate\".to_string(),\n        \"Perform basic mathematical calculations\".to_string(),\n        |args, _context| Box::pin(async move {\n            let expression = args\n                .get(\"expression\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\");\n\n            let result = match expression {\n                \"2+2\" =&gt; 4,\n                \"10*5\" =&gt; 50,\n                \"100/4\" =&gt; 25,\n                \"15-3\" =&gt; 12,\n                _ =&gt; {\n                    return ToolResult::error(format!(\"Cannot calculate: {}\", expression));\n                }\n            };\n\n            ToolResult::success(json!({\"result\": result, \"expression\": expression}))\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"expression\": {\n                \"type\": \"string\",\n                \"description\": \"Mathematical expression to evaluate (e.g., '2+2', '10*5')\"\n            }\n        },\n        \"required\": [\"expression\"]\n    }))\n}\n\n// Add tools to your agent using a toolset\nuse radkit::tools::SimpleToolset;\n\nlet toolset = SimpleToolset::new()\n    .add_tool(create_weather_tool())\n    .add_tool(create_calculator_tool());\n\nlet agent = Agent::builder(\n        \"You are a helpful assistant. Use the available tools when requested by the user.\",\n        llm,\n    )\n    .with_card(|c| c\n        .with_name(\"tool_agent\")\n        .with_description(\"Agent with custom tools\")\n    )\n    .with_toolset(toolset)\n    .build();\n</code></pre>"},{"location":"getting-started/#5-monitoring-tool-calls-and-responses","title":"5. Monitoring Tool Calls and Responses","text":"<p>Tool calls and responses are captured in session events and can be monitored in real-time via streaming:</p> <pre><code>use futures::StreamExt;\nuse radkit::a2a::SendStreamingMessageResult;\n\n// Send a message that will trigger tool usage\nlet message = create_user_message(\n    \"What's the weather like in San Francisco? Please use the get_weather tool.\"\n);\n\nlet params = MessageSendParams {\n    message,\n    configuration: None,\n    metadata: None,\n};\n\n// Use streaming to monitor tool calls in real-time\nlet mut execution = agent.send_streaming_message(\n    \"test_app\".to_string(),\n    \"test_user\".to_string(),\n    params\n).await?;\n\nlet mut final_task = None;\n\n// Process A2A events and monitor tool responses\nwhile let Some(event) = execution.a2a_stream.next().await {\n    match event {\n        SendStreamingMessageResult::Message(msg) =&gt; {\n            // Agent's response includes tool results\n            println!(\"\ud83d\udcac Agent (role={:?}):\", msg.role);\n            for part in &amp;msg.parts {\n                if let Part::Text { text, .. } = part {\n                    println!(\"  {}\", text);\n                }\n            }\n        }\n        SendStreamingMessageResult::Task(task) =&gt; {\n            final_task = Some(task);\n            break;\n        }\n        _ =&gt; {}\n    }\n}\n\n// Tool calls are persisted in session events with detailed information\nif let Some(task) = final_task {\n    let session_service = agent.session_service();\n    let session = session_service\n        .get_session(\"test_app\", \"test_user\", &amp;task.context_id)\n        .await?\n        .expect(\"Session should exist\");\n\n    println!(\"\\n\ud83d\udccb Session Events Summary:\");\n    println!(\"  Total events: {}\", session.events.len());\n\n    // Count different types of content in session events\n    let mut tool_calls = 0;\n    let mut tool_responses = 0;\n\n    for event in &amp;session.events {\n        if let radkit::sessions::SessionEventType::UserMessage { content }\n        | radkit::sessions::SessionEventType::AgentMessage { content } = &amp;event.event_type {\n            for part in &amp;content.parts {\n                match part {\n                    radkit::models::content::ContentPart::FunctionCall { name, .. } =&gt; {\n                        tool_calls += 1;\n                        println!(\"  \ud83d\udd27 Tool Call: {}\", name);\n                    }\n                    radkit::models::content::ContentPart::FunctionResponse { name, success, .. } =&gt; {\n                        tool_responses += 1;\n                        println!(\"  \u2699\ufe0f Tool Response: {} (success: {})\", name, success);\n                    }\n                    _ =&gt; {}\n                }\n            }\n        }\n    }\n\n    println!(\"  Tool calls: {}, Tool responses: {}\", tool_calls, tool_responses);\n}\n</code></pre>"},{"location":"getting-started/#6-tool-error-handling","title":"6. Tool Error Handling","text":"<p>Handle tool failures gracefully:</p> <pre><code>// Create a tool that sometimes fails for demonstration\nlet error_tool = FunctionTool::new(\n    \"risky_operation\".to_string(),\n    \"An operation that might fail\".to_string(),\n    |args, _context| Box::pin(async move {\n        let input = args.get(\"input\").and_then(|v| v.as_str()).unwrap_or(\"\");\n\n        if input == \"fail\" {\n            ToolResult::error(\"Operation failed as requested\".to_string())\n        } else {\n            ToolResult::success(json!({ \"result\": \"Operation succeeded\" }))\n        }\n    }),\n)\n.with_parameters_schema(json!({\n    \"type\": \"object\",\n    \"properties\": {\n        \"input\": {\n            \"type\": \"string\",\n            \"description\": \"Input parameter - use 'fail' to trigger error\"\n        }\n    },\n    \"required\": [\"input\"]\n}));\n\n// Monitor tool failures through session events after completion\nlet response = agent.send_message(app, user, params).await?;\n\nif let SendMessageResult::Task(task) = response.result {\n    // Check session events for tool failures\n    let session_service = agent.session_service();\n    let session = session_service\n        .get_session(\"test_app\", \"test_user\", &amp;task.context_id)\n        .await?\n        .expect(\"Session should exist\");\n\n    for event in &amp;session.events {\n        if let radkit::sessions::SessionEventType::UserMessage { content }\n        | radkit::sessions::SessionEventType::AgentMessage { content } = &amp;event.event_type {\n            for part in &amp;content.parts {\n                if let radkit::models::content::ContentPart::FunctionResponse { \n                    name, success, error_message, .. \n                } = part {\n                    if !success {\n                        println!(\"\u274c Tool '{}' failed: {}\", name, \n                            error_message.as_deref().unwrap_or(\"Unknown error\"));\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#streaming-vs-non-streaming","title":"Streaming vs Non-Streaming","text":""},{"location":"getting-started/#non-streaming-complete-response","title":"Non-Streaming (Complete Response)","text":"<p>Best for: Simple queries, batch processing, testing</p> <pre><code>let execution = agent.send_message(app, user, params).await?;\n\n// Access the complete response\nif let SendMessageResult::Task(task) = execution.result {\n    println!(\"Task completed: {}\", task.id);\n}\n\n// Access ALL events including function calls/responses\nprintln!(\"Total events captured: {}\", execution.all_events.len());\n\nfor event in &amp;execution.all_events {\n    match &amp;event.event_type {\n        radkit::sessions::SessionEventType::UserMessage { content } |\n        radkit::sessions::SessionEventType::AgentMessage { content } =&gt; {\n            // Check for function calls and responses\n            for part in &amp;content.parts {\n                match part {\n                    radkit::models::content::ContentPart::FunctionCall { name, arguments, .. } =&gt; {\n                        println!(\"\ud83d\udd27 Function called: {} with args: {:?}\", name, arguments);\n                    }\n                    radkit::models::content::ContentPart::FunctionResponse { \n                        name, success, result, error_message, duration_ms, .. \n                    } =&gt; {\n                        println!(\"\u2699\ufe0f Function {} returned (success: {})\", name, success);\n                        if *success {\n                            println!(\"   Result: {:?}\", result);\n                        } else if let Some(err) = error_message {\n                            println!(\"   Error: {}\", err);\n                        }\n                        if let Some(ms) = duration_ms {\n                            println!(\"   Duration: {}ms\", ms);\n                        }\n                    }\n                    radkit::models::content::ContentPart::Text { text, .. } =&gt; {\n                        if content.role == MessageRole::Agent {\n                            println!(\"\ud83d\udcac Agent: {}\", text);\n                        }\n                    }\n                    _ =&gt; {}\n                }\n            }\n        }\n        radkit::sessions::SessionEventType::TaskStatusChanged { new_state, .. } =&gt; {\n            println!(\"\ud83d\udcca Task status: {:?}\", new_state);\n        }\n        radkit::sessions::SessionEventType::ArtifactSaved { artifact } =&gt; {\n            println!(\"\ud83d\udcbe Artifact saved: {:?}\", artifact.name);\n        }\n        _ =&gt; {}\n    }\n}\n\n// Access A2A protocol events only (filtered subset)\nprintln!(\"A2A events: {}\", execution.a2a_events.len());\n</code></pre>"},{"location":"getting-started/#streaming-real-time-response","title":"Streaming (Real-Time Response)","text":"<p>Best for: Interactive chat, progress updates, long-running tasks</p> <pre><code>use futures::StreamExt;\nuse radkit::a2a::{SendStreamingMessageResult, TaskState};\n\n// Create a message that will trigger tool usage\nlet message = create_user_message(\n    \"Please update the task status to 'working' and save a config file as an artifact.\"\n);\n\nlet params = MessageSendParams {\n    message,\n    configuration: None,\n    metadata: None,\n};\n\n// Use streaming to capture events in real-time\nlet mut execution = agent.send_streaming_message(\n    \"my_app\".to_string(),\n    \"user123\".to_string(),\n    params\n).await?;\n\n// Option 1: Monitor A2A protocol events (for UI updates)\nlet mut status_updates = 0;\nlet mut artifacts = 0;\nlet mut final_task = None;\n\n// Process A2A events as they arrive\nwhile let Some(event) = execution.a2a_stream.next().await {\n    match event {\n        SendStreamingMessageResult::Message(msg) =&gt; {\n            // Real-time message content\n            for part in &amp;msg.parts {\n                if let Part::Text { text, .. } = part {\n                    print!(\"{}\", text);\n                }\n            }\n        }\n        SendStreamingMessageResult::TaskStatusUpdate(update) =&gt; {\n            status_updates += 1;\n            println!(\"\u2705 Status update: {:?} (final: {})\", \n                update.status.state, update.is_final);\n        }\n        SendStreamingMessageResult::TaskArtifactUpdate(update) =&gt; {\n            artifacts += 1;\n            println!(\"\u2705 Artifact saved: {:?}\", update.artifact.name);\n        }\n        SendStreamingMessageResult::Task(task) =&gt; {\n            // Final complete task\n            final_task = Some(task);\n            break;\n        }\n    }\n}\n\nprintln!(\"Streaming completed: {} status updates, {} artifacts\", status_updates, artifacts);\n\n// Option 2: Also monitor ALL events stream for detailed debugging\n// You can spawn a task to monitor all_events_stream in parallel\ntokio::spawn(async move {\n    let mut all_events_stream = execution.all_events_stream;\n\n    while let Some(event) = all_events_stream.next().await {\n        match &amp;event.event_type {\n            radkit::sessions::SessionEventType::UserMessage { content } |\n            radkit::sessions::SessionEventType::AgentMessage { content } =&gt; {\n                // Monitor function calls and responses in real-time\n                for part in &amp;content.parts {\n                    match part {\n                        radkit::models::content::ContentPart::FunctionCall { name, arguments, .. } =&gt; {\n                            println!(\"\ud83d\udd27 [DEBUG] Function called: {} with {:?}\", name, arguments);\n                        }\n                        radkit::models::content::ContentPart::FunctionResponse { \n                            name, success, result, duration_ms, .. \n                        } =&gt; {\n                            println!(\"\u2699\ufe0f [DEBUG] Function {} returned in {:?}ms (success: {})\", \n                                name, duration_ms, success);\n                            if *success {\n                                println!(\"   [DEBUG] Result: {:?}\", result);\n                            }\n                        }\n                        _ =&gt; {}\n                    }\n                }\n            }\n            radkit::sessions::SessionEventType::TaskCreated { .. } =&gt; {\n                println!(\"\ud83d\udccb [DEBUG] Task created\");\n            }\n            radkit::sessions::SessionEventType::StateChanged { key, new_value, .. } =&gt; {\n                println!(\"\ud83d\udcdd [DEBUG] State changed: {} = {}\", key, new_value);\n            }\n            _ =&gt; {}\n        }\n    }\n});\n\n// Access session events for debugging after completion\nif let Some(task) = &amp;final_task {\n    let session_service = agent.session_service();\n    let session = session_service\n        .get_session(\"my_app\", \"user123\", &amp;task.context_id)\n        .await?\n        .expect(\"Session should exist\");\n    println!(\"Session has {} total events\", session.events.len());\n}\n</code></pre>"},{"location":"getting-started/#event-monitoring","title":"Event Monitoring","text":"<p>Both streaming and non-streaming modes capture events in the session:</p> <pre><code>use radkit::models::content::ContentPart;\n\n// Access session events after completion\nlet session_service = agent.session_service();\nlet session = session_service\n    .get_session(\"test_app\", \"test_user\", &amp;task.context_id)\n    .await?\n    .expect(\"Session should exist\");\n\n// Monitor all activity in the session\nprintln!(\"\ud83d\udccb Session Event Summary:\");\nprintln!(\"  Total events: {}\", session.events.len());\n\nfor event in &amp;session.events {\n    match &amp;event.event_type {\n        radkit::sessions::SessionEventType::UserMessage { content } =&gt; {\n            println!(\"\ud83d\udc64 User message: {}\", \n                content.parts.iter()\n                    .filter_map(|p| match p {\n                        ContentPart::Text { text, .. } =&gt; Some(text.chars().take(50).collect::&lt;String&gt;()),\n                        _ =&gt; None\n                    })\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\n                    .join(\", \")\n            );\n        }\n        radkit::sessions::SessionEventType::AgentMessage { content } =&gt; {\n            println!(\"\ud83e\udd16 Agent response\");\n\n            // Monitor tool calls and responses\n            for part in &amp;content.parts {\n                match part {\n                    ContentPart::FunctionCall { name, arguments, .. } =&gt; {\n                        println!(\"  \ud83d\udd27 Function Call: {} with args: {:?}\", name, arguments);\n                    }\n                    ContentPart::FunctionResponse { name, success, result, error_message, duration_ms, .. } =&gt; {\n                        println!(\"  \u2699\ufe0f Function Response: {} (success: {})\", name, success);\n                        if let Some(error) = error_message {\n                            println!(\"     Error: {}\", error);\n                        }\n                        if let Some(duration) = duration_ms {\n                            println!(\"     Duration: {}ms\", duration);\n                        }\n                    }\n                    ContentPart::Text { text, .. } =&gt; {\n                        println!(\"  \ud83d\udcac Text: {}\", text.chars().take(50).collect::&lt;String&gt;());\n                    }\n                    _ =&gt; {}\n                }\n            }\n        }\n        radkit::sessions::SessionEventType::TaskStatusChanged { new_state, .. } =&gt; {\n            println!(\"\ud83d\udcca Task status changed to: {:?}\", new_state);\n        }\n        radkit::sessions::SessionEventType::ArtifactSaved { artifact } =&gt; {\n            println!(\"\ud83d\udcbe Artifact saved: {:?}\", artifact.name);\n        }\n        radkit::sessions::SessionEventType::StateChanged { key, new_value, scope, .. } =&gt; {\n            println!(\"\ud83d\udcdd State changed: {} = {} (scope: {:?})\", key, new_value, scope);\n        }\n        _ =&gt; {}\n    }\n}\n</code></pre>"},{"location":"getting-started/#complete-example-math-tutor-agent","title":"Complete Example: Math Tutor Agent","text":"<pre><code>use radkit::a2a::{Message, MessageRole, MessageSendParams, Part, SendMessageResult};\nuse radkit::agents::{Agent, AgentConfig};\nuse radkit::models::AnthropicLlm;\nuse radkit::sessions::SessionEventType;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    dotenvy::dotenv().ok();\n\n    // Create a specialized math tutor agent\n    let llm = AnthropicLlm::new(\n        \"claude-3-5-sonnet-20241022\".to_string(),\n        std::env::var(\"ANTHROPIC_API_KEY\")?,\n    );\n\n    let agent = Agent::builder(\n        r#\"You are a patient math tutor. When solving problems:\n        1. Break down the problem into steps\n        2. Explain each step clearly\n        3. Use the save_artifact tool to save the solution\n        4. Update your status as you work through the problem\"#,\n        llm,\n    )\n    .with_card(|c| c\n        .with_name(\"MathTutor\")\n        .with_description(\"An AI math tutor that explains concepts step-by-step\")\n    )\n    .with_config(AgentConfig::default().with_max_iterations(10))\n    .with_builtin_task_tools()\n    .build();\n\n    // Student asks a question\n    let question = \"A train travels 120 miles in 2 hours. What is its average speed?\";\n\n    let params = MessageSendParams {\n        message: Message {\n            kind: \"message\".to_string(),\n            message_id: uuid::Uuid::new_v4().to_string(),\n            role: MessageRole::User,\n            parts: vec![Part::Text {\n                text: question.to_string(),\n                metadata: None,\n            }],\n            context_id: None,\n            task_id: None,\n            reference_task_ids: Vec::new(),\n            extensions: Vec::new(),\n            metadata: None,\n        },\n        configuration: None,\n        metadata: None,\n    };\n\n    println!(\"\ud83d\udcda Math Tutor Agent\");\n    println!(\"Student: {}\\n\", question);\n\n    // Get the solution\n    let response = agent.send_message(\n        \"math_tutor_app\".to_string(),\n        \"student_001\".to_string(),\n        params,\n    ).await?;\n\n    // Display the response\n    if let SendMessageResult::Task(task) = response.result {\n        // Find the tutor's explanation\n        for message in &amp;task.history {\n            if message.role == MessageRole::Agent {\n                println!(\"Tutor:\");\n                for part in &amp;message.parts {\n                    if let Part::Text { text, .. } = part {\n                        println!(\"{}\", text);\n                    }\n                }\n            }\n        }\n\n        // Check for saved solutions\n        if !task.artifacts.is_empty() {\n            println!(\"\\n\ud83d\udcdd Saved Solutions:\");\n            for artifact in &amp;task.artifacts {\n                if let Some(name) = &amp;artifact.name {\n                    println!(\"- {}\", name);\n                }\n            }\n        }\n\n        println!(\"\\n\u2705 Task Status: {:?}\", task.status.state);\n    }\n\n    // Analyze session events\n    let session_service = agent.session_service();\n    let session = session_service\n        .get_session(\"math_tutor_app\", \"student_001\", &amp;task.context_id)\n        .await?\n        .expect(\"Session should exist\");\n\n    println!(\"\ud83d\udcca Session Analysis:\");\n    println!(\"  Total events: {}\", session.events.len());\n\n    let mut message_events = 0;\n    let mut status_changes = 0;\n    let mut artifacts = 0;\n\n    for event in &amp;session.events {\n        match &amp;event.event_type {\n            radkit::sessions::SessionEventType::UserMessage { .. } | \n            radkit::sessions::SessionEventType::AgentMessage { .. } =&gt; {\n                message_events += 1;\n            }\n            radkit::sessions::SessionEventType::TaskStatusChanged { .. } =&gt; {\n                status_changes += 1;\n            }\n            radkit::sessions::SessionEventType::ArtifactSaved { .. } =&gt; {\n                artifacts += 1;\n            }\n            _ =&gt; {}\n        }\n    }\n\n    println!(\"  Messages: {}, Status changes: {}, Artifacts: {}\", \n        message_events, status_changes, artifacts);\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<p>Always handle potential errors gracefully:</p> <pre><code>use radkit::errors::AgentError;\n\nmatch agent.send_message(app, user, params).await {\n    Ok(response) =&gt; {\n        // Process successful execution\n    }\n    Err(AgentError::LlmRateLimit { provider }) =&gt; {\n        println!(\"Rate limited by {}. Retrying in 60 seconds...\", provider);\n        tokio::time::sleep(Duration::from_secs(60)).await;\n        // Retry logic\n    }\n    Err(AgentError::SessionNotFound { session_id, .. }) =&gt; {\n        println!(\"Session {} not found. Creating new session...\", session_id);\n        // Create new session\n    }\n    Err(e) =&gt; {\n        eprintln!(\"Error: {}\", e);\n        // Generic error handling\n    }\n}\n</code></pre>"},{"location":"getting-started/#best-practices","title":"Best Practices","text":"<ol> <li>Always Use Multi-Tenancy: Provide app_name and user_id for proper isolation</li> <li>Enable Built-in Tools: Use <code>with_builtin_task_tools()</code> for task management</li> <li>Monitor Events: Use captured events for debugging and observability</li> <li>Handle Errors: Implement proper error handling and retry logic</li> <li>Use Streaming for Interactive Apps: Better user experience with real-time responses</li> <li>Set Appropriate Timeouts: Configure max_iterations to prevent infinite loops</li> <li>Secure API Keys: Never hardcode API keys; use environment variables</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Tasks Guide - Understand task lifecycle</li> <li>Sessions Guide - Learn about state management</li> </ul>"},{"location":"sessions/","title":"Session Management Guide","text":"<p>Sessions in Radkit provide sophisticated state management with three-tier isolation, automatic preference merging, and complete multi-tenant security. This guide covers everything you need to know about managing conversation state in your agents.</p>"},{"location":"sessions/#understanding-sessions","title":"Understanding Sessions","text":"<p>A Session represents a conversation context that: - Maps to the A2A protocol's <code>contextId</code> - Groups related tasks and interactions - Maintains state across multiple message exchanges - Provides automatic preference inheritance from app and user levels</p>"},{"location":"sessions/#event-driven-conversation-architecture","title":"Event-Driven Conversation Architecture","text":"<p>Key Concept: Radkit sessions store events rather than static message history. When an agent needs to understand conversation context, it dynamically reconstructs the full conversation from <code>session.events</code>.</p> <pre><code>// From EventProcessor - how conversations are built:\nasync fn get_llm_conversation(\n    &amp;self,\n    app_name: &amp;str,\n    user_id: &amp;str,\n    context_id: &amp;str,\n) -&gt; AgentResult&lt;Vec&lt;Content&gt;&gt; {\n    let session = self.session_service\n        .get_session(app_name, user_id, context_id)\n        .await?\n        .ok_or_else(|| AgentError::SessionNotFound { \n            app_name: app_name.to_string(),\n            user_id: user_id.to_string(),\n            session_id: context_id.to_string(),\n        })?;\n\n    let mut content_messages = Vec::new();\n\n    for event in &amp;session.events {\n        match &amp;event.event_type {\n            SessionEventType::UserMessage { content } |\n            SessionEventType::AgentMessage { content } =&gt; {\n                // Each message event becomes part of conversation\n                content_messages.push(content.clone());\n            }\n            _ =&gt; {\n                // Other events (StateChange, TaskCreated) don't affect conversation flow\n            }\n        }\n    }\n\n    Ok(content_messages)\n}\n</code></pre> <p>This event-driven approach means: - Cross-Task Memory: Conversations span multiple tasks within the same session - Rich Context: Function calls, responses, and metadata are preserved - A2A Native: Session ID maps directly to A2A <code>contextId</code>  - Efficient Storage: Only events are stored, messages are reconstructed as needed</p>"},{"location":"sessions/#basic-session-operations","title":"Basic Session Operations","text":""},{"location":"sessions/#creating-a-new-session","title":"Creating a New Session","text":"<p>Sessions are created automatically when you send a message without a <code>context_id</code>:</p> <pre><code>use radkit::a2a::{Message, MessageRole, MessageSendParams, Part, SendMessageResult};\nuse radkit::agents::Agent;\n\n// Message without context_id creates a new session\nlet params = MessageSendParams {\n    message: Message {\n        kind: \"message\".to_string(),\n        message_id: uuid::Uuid::new_v4().to_string(),\n        role: MessageRole::User,\n        parts: vec![Part::Text {\n            text: \"Start a new conversation\".to_string(),\n            metadata: None,\n        }],\n        context_id: None,  // \u2190 New session will be created\n        task_id: None,\n        reference_task_ids: Vec::new(),\n        extensions: Vec::new(),\n        metadata: None,\n    },\n    configuration: None,\n    metadata: None,\n};\n\nlet response = agent.send_message(\n    \"my_app\".to_string(),\n    \"user123\".to_string(),\n    params,\n).await?;\n\n// The created session ID is in the task's context_id\nif let SendMessageResult::Task(task) = response.result {\n    println!(\"New session created: {}\", task.context_id);\n}\n</code></pre>"},{"location":"sessions/#continuing-an-existing-session","title":"Continuing an Existing Session","text":"<p>To continue a conversation in the same session:</p> <pre><code>// Continue in the same session\nlet mut params = create_message_params(\"Follow-up question\");\nparams.message.context_id = Some(\"existing_session_id\".to_string());\n\nlet response = agent.send_message(\n    \"my_app\".to_string(),\n    \"user123\".to_string(),\n    params,\n).await?;\n</code></pre>"},{"location":"sessions/#three-tier-state-architecture-work-in-progress","title":"Three-Tier State Architecture [ WORK IN PROGRESS]","text":"<p>Radkit implements a powerful three-tier state management system:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         App-Level State             \u2502\n\u2502   (Shared across all users)         \u2502\n\u2502   Examples: max_tokens, api_config  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        User-Level State             \u2502\n\u2502    (Per-user preferences)           \u2502\n\u2502   Examples: language, timezone      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Session-Level State           \u2502\n\u2502   (Conversation-specific)           \u2502\n\u2502   Examples: topic, temp_data        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"sessions/#state-merging","title":"State Merging","text":"<p>When you retrieve a session, states are automatically merged: - Session state takes priority (most specific) - User state overrides app state - App state provides defaults</p>"},{"location":"tasks/","title":"Task Management Guide","text":"<p>Tasks in Radkit represent units of work that agents perform. They follow the A2A protocol specification and provide comprehensive lifecycle management, artifact generation, and event streaming. This guide covers everything you need to know about working with tasks.</p>"},{"location":"tasks/#understanding-tasks","title":"Understanding Tasks","text":"<p>A Task is the fundamental unit of work in the A2A protocol: - Contains a complete conversation history - Tracks status through a defined lifecycle - Stores generated artifacts (files, analysis, etc.) - Emits A2A-compliant events for real-time monitoring - Provides thread-safe atomic operations</p>"},{"location":"tasks/#task-lifecycle","title":"Task Lifecycle","text":"<p>Tasks progress through well-defined states:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Submitted \u2502 -&gt; \u2502Working  \u2502 -&gt; \u2502InputRequired \u2502 -&gt; \u2502Completed  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502              \u2502                    \u2191\n                     \u2502              \u2193                    \u2502\n                     \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n                     \u2502         \u2502AuthRequired  \u2502 --------\u2518\n                     \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u2193\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2502Failed/Rejected  \u2502\n             \u2502   /Canceled     \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tasks/#task-states","title":"Task States","text":"<ul> <li>Submitted: Initial state when task is created</li> <li>Working: Agent is actively processing the task</li> <li>InputRequired: Agent needs additional input from user</li> <li>AuthRequired: Agent needs authentication or permissions</li> <li>Completed: Task finished successfully</li> <li>Failed: Task failed due to error</li> <li>Rejected: Task was rejected (e.g., inappropriate request)</li> <li>Canceled: Task was canceled by user or system</li> </ul>"},{"location":"tasks/#creating-and-managing-tasks","title":"Creating and Managing Tasks","text":""},{"location":"tasks/#automatic-task-creation","title":"Automatic Task Creation","text":"<p>Tasks are created automatically when you send a message without a <code>task_id</code>:</p> <pre><code>use radkit::a2a::{Message, MessageRole, MessageSendParams, Part, SendMessageResult};\nuse radkit::agents::Agent;\n\nlet params = MessageSendParams {\n    message: Message {\n        kind: \"message\".to_string(),\n        message_id: uuid::Uuid::new_v4().to_string(),\n        role: MessageRole::User,\n        parts: vec![Part::Text {\n            text: \"Analyze this data and create a report\".to_string(),\n            metadata: None,\n        }],\n        context_id: None,  // New session will be created\n        task_id: None,     // New task will be created\n        reference_task_ids: Vec::new(),\n        extensions: Vec::new(),\n        metadata: None,\n    },\n    configuration: None,\n    metadata: None,\n};\n\nlet response = agent.send_message(\n    \"analytics_app\".to_string(),\n    \"analyst_001\".to_string(),\n    params,\n).await?;\n\nif let SendMessageResult::Task(task) = response.result {\n    println!(\"New task created: {}\", task.id);\n    println!(\"Initial status: {:?}\", task.status.state);\n}\n</code></pre>"},{"location":"tasks/#continuing-existing-tasks","title":"Continuing Existing Tasks","text":"<p>To add messages to an existing task:</p> <pre><code>// Continue working on an existing task\nlet mut params = MessageSendParams {\n    message: Message {\n        kind: \"message\".to_string(),\n        message_id: uuid::Uuid::new_v4().to_string(),\n        role: MessageRole::User,\n        parts: vec![Part::Text {\n            text: \"Please add more details to the analysis\".to_string(),\n            metadata: None,\n        }],\n        context_id: Some(\"existing_context_id\".to_string()),\n        task_id: Some(\"existing_task_id\".to_string()),  // \u2190 Continue this task\n        reference_task_ids: Vec::new(),\n        extensions: Vec::new(),\n        metadata: None,\n    },\n    configuration: None,\n    metadata: None,\n};\n\nlet execution = agent.send_message(app, user, params).await?;\n</code></pre>"},{"location":"tasks/#direct-task-access","title":"Direct Task Access","text":"<p>You can also work with tasks directly through the Agent API:</p> <pre><code>use radkit::a2a::TaskQueryParams;\n\n// Get a specific task\nlet task = agent.get_task(\n    \"my_app\".to_string(),\n    \"user123\".to_string(), \n    TaskQueryParams {\n        id: \"task_id_here\".to_string(),\n        history_length: None,\n        metadata: None,\n    }\n).await?;\n\nprintln!(\"Task status: {:?}\", task.status.state);\nprintln!(\"Messages in history: {}\", task.history.len());\nprintln!(\"Artifacts: {}\", task.artifacts.len());\n\n// List all tasks for a user (using the A2A list_tasks method)\nlet all_tasks = agent.list_tasks(\n    \"my_app\".to_string(),\n    \"user123\".to_string(),\n    None  // No context filter\n).await?;\n\nprintln!(\"User has {} total tasks\", all_tasks.len());\n\n// List tasks for a specific session\nlet session_tasks = agent.list_tasks(\n    \"my_app\".to_string(),\n    \"user123\".to_string(),\n    Some(\"session_id\".to_string())  // Filter by context\n).await?;\n</code></pre>"},{"location":"tasks/#built-in-task-management-tools","title":"Built-in Task Management Tools","text":"<p>Radkit provides built-in tools that agents can use to manage their own task lifecycle:</p>"},{"location":"tasks/#enabling-built-in-tools","title":"Enabling Built-in Tools","text":"<pre><code>use radkit::agents::AgentConfig;\n\nlet config = AgentConfig::default().with_max_iterations(10);\n\nlet agent = Agent::builder(\n        \"You can update task status and save artifacts using built-in tools.\".to_string(),\n        anthropic_llm,\n    )\n    .with_card(|c| c.with_name(\"builtin_agent\".to_string()).with_description(\"Agent with built-in tools\".to_string()))\n    .build()\n.with_config(config)\n.with_builtin_task_tools();  // Enables update_status and save_artifact\n</code></pre>"},{"location":"tasks/#the-update_status-tool","title":"The update_status Tool","text":"<p>This tool allows agents to control their task status:</p> <pre><code>// Agent can use this tool in their LLM calls\n// The tool generates A2A TaskStatusUpdate events automatically\n\n// Example tool usage by agent:\n// {\n//   \"function_call\": {\n//     \"name\": \"update_status\",\n//     \"args\": {\n//       \"status\": \"working\",\n//       \"message\": \"Starting data analysis...\"\n//     }\n//   }\n// }\n</code></pre> <p>Available status values: - <code>\"submitted\"</code>, <code>\"working\"</code>, <code>\"input_required\"</code>, <code>\"auth_required\"</code> - <code>\"completed\"</code>, <code>\"failed\"</code>, <code>\"rejected\"</code>, <code>\"canceled\"</code></p>"},{"location":"tasks/#the-save_artifact-tool","title":"The save_artifact Tool","text":"<p>This tool allows agents to save important outputs:</p> <pre><code>// Agent can save artifacts during execution\n// The tool generates A2A TaskArtifactUpdate events automatically\n\n// Example tool usage by agent:\n// {\n//   \"function_call\": {\n//     \"name\": \"save_artifact\",\n//     \"args\": {\n//       \"name\": \"Data Analysis Report\",\n//       \"content\": \"...\",\n//       \"content_type\": \"text/markdown\",\n//       \"description\": \"Comprehensive analysis of the provided dataset\"\n//     }\n//   }\n// }\n</code></pre>"},{"location":"tasks/#working-with-task-artifacts","title":"Working with Task Artifacts","text":"<p>Artifacts represent outputs generated by agents:</p> <pre><code>use radkit::a2a::{Artifact, Part, TaskQueryParams};\n\n// Access artifacts from a completed task\nlet retrieved_task = agent.get_task(\n    \"app\",\n    \"user\", \n    TaskQueryParams {\n        id: \"task_id\".to_string(),\n        history_length: None,\n        metadata: None,\n    }\n).await?;\n\nfor artifact in &amp;retrieved_task.artifacts {\n    println!(\"Artifact: {}\", artifact.artifact_id);\n\n    if let Some(name) = &amp;artifact.name {\n        println!(\"  Name: {}\", name);\n    }\n\n    if let Some(desc) = &amp;artifact.description {\n        println!(\"  Description: {}\", desc);\n    }\n\n    // Access content\n    for part in &amp;artifact.parts {\n        match part {\n            Part::Text { text, .. } =&gt; {\n                println!(\"  Text content: {} chars\", text.len());\n            }\n            Part::File { file, .. } =&gt; {\n                println!(\"  File content: {:?}\", file);\n            }\n            Part::Data { data, .. } =&gt; {\n                println!(\"  Data content: {}\", data);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"tasks/#task-events-and-monitoring","title":"Task Events and Monitoring","text":"<p>Tasks automatically generate A2A-compliant events:</p>"},{"location":"tasks/#taskstatusupdate-events","title":"TaskStatusUpdate Events","text":"<p>Generated when task status changes:</p> <pre><code>// Monitor status updates in streaming mode\nwhile let Some(event) = execution.a2a_stream.next().await {\n    if let SendStreamingMessageResult::TaskStatusUpdate(update) = event {\n        println!(\"Task {} status: {:?}\", update.task_id, update.status.state);\n\n        if update.is_final {\n            println!(\"Task reached final state\");\n        }\n\n        // Check for status message\n        if let Some(msg) = &amp;update.status.message {\n            for part in &amp;msg.parts {\n                if let Part::Text { text, .. } = part {\n                    println!(\"Status message: {}\", text);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"tasks/#taskartifactupdate-events","title":"TaskArtifactUpdate Events","text":"<p>Generated when artifacts are added:</p> <pre><code>// Monitor artifact updates\nwhile let Some(event) = execution.a2a_stream.next().await {\n    if let SendStreamingMessageResult::TaskArtifactUpdate(update) = event {\n        println!(\"New artifact: {}\", update.artifact.artifact_id);\n\n        if let Some(name) = &amp;update.artifact.name {\n            println!(\"  Name: {}\", name);\n        }\n\n        // Check if this is the final chunk\n        if update.last_chunk == Some(true) {\n            println!(\"  Artifact complete\");\n        }\n    }\n}\n</code></pre>"},{"location":"tasks/#error-handling-and-recovery","title":"Error Handling and Recovery","text":""},{"location":"tasks/#handling-failed-tasks","title":"Handling Failed Tasks","text":"<pre><code>use radkit::errors::AgentError;\n\nasync fn handle_task_failure(\n    agent: &amp;Agent,\n    app_name: &amp;str,\n    user_id: &amp;str,\n    failed_task_id: &amp;str,\n) -&gt; Result&lt;Task, Box&lt;dyn std::error::Error&gt;&gt; {\n\n    // Get the failed task\n    let failed_task = agent.get_task(\n        app_name.to_string(),\n        user_id.to_string(),\n        TaskQueryParams {\n            id: failed_task_id.to_string(),\n            history_length: None,\n            metadata: None,\n        }\n    ).await?;\n\n    // Analyze failure\n    let failure_reason = failed_task.status.message.as_ref()\n        .and_then(|msg| msg.parts.first())\n        .and_then(|part| match part {\n            Part::Text { text, .. } =&gt; Some(text.clone()),\n            _ =&gt; None,\n        })\n        .unwrap_or_else(|| \"Unknown failure\".to_string());\n\n    println!(\"Task failed: {}\", failure_reason);\n\n    // Create recovery task\n    let recovery_prompt = format!(\n        \"The previous task failed with error: {}\\n\\\n         Please analyze the failure and create a corrected version.\\n\\\n         Original request was: {}\",\n        failure_reason,\n        extract_original_request(&amp;failed_task)\n    );\n\n    let params = create_message_params(&amp;recovery_prompt);\n    let execution = agent.send_message(\n        app_name.to_string(),\n        user_id.to_string(),\n        params,\n    ).await?;\n\n    if let SendMessageResult::Task(recovery_task) = execution.result {\n        Ok(recovery_task)\n    } else {\n        Err(\"Recovery task creation failed\".into())\n    }\n}\n\nfn extract_original_request(task: &amp;Task) -&gt; String {\n    task.history.iter()\n        .find(|msg| msg.role == MessageRole::User)\n        .and_then(|msg| msg.parts.first())\n        .and_then(|part| match part {\n            Part::Text { text, .. } =&gt; Some(text.clone()),\n            _ =&gt; None,\n        })\n        .unwrap_or_else(|| \"No original request found\".to_string())\n}\n</code></pre>"},{"location":"tasks/#best-practices","title":"Best Practices","text":""},{"location":"tasks/#1-handle-all-task-states","title":"1. Handle All Task States","text":"<pre><code>match task.status.state {\n    TaskState::Submitted =&gt; println!(\"Task queued\"),\n    TaskState::Working =&gt; println!(\"Task in progress\"),\n    TaskState::InputRequired =&gt; {\n        // Handle input requirement\n        println!(\"Waiting for user input\");\n    }\n    TaskState::AuthRequired =&gt; {\n        // Handle authentication\n        println!(\"Authentication needed\");\n    }\n    TaskState::Completed =&gt; {\n        // Process successful completion\n        println!(\"Task completed successfully\");\n    }\n    TaskState::Failed =&gt; {\n        // Handle failure\n        println!(\"Task failed - check error details\");\n    }\n    TaskState::Rejected =&gt; {\n        // Handle rejection\n        println!(\"Task was rejected\");\n    }\n    TaskState::Canceled =&gt; {\n        // Handle cancellation\n        println!(\"Task was canceled\");\n    }\n}\n</code></pre>"},{"location":"tasks/#2-monitor-task-progress","title":"2. Monitor Task Progress","text":"<pre><code>use std::time::Instant;\n\nasync fn monitor_task_with_timeout(\n    agent: &amp;Agent,\n    app_name: String,\n    user_id: String,\n    params: MessageSendParams,\n    timeout_seconds: u64,\n) -&gt; Result&lt;Task, Box&lt;dyn std::error::Error&gt;&gt; {\n\n    let start = Instant::now();\n    let mut execution = agent.send_streaming_message(app_name, user_id, params).await?;\n\n    while let Some(event) = execution.a2a_stream.next().await {\n        // Check timeout\n        if start.elapsed().as_secs() &gt; timeout_seconds {\n            return Err(\"Task timeout\".into());\n        }\n\n        match event {\n            SendStreamingMessageResult::Task(task) =&gt; {\n                return Ok(task);\n            }\n            SendStreamingMessageResult::TaskStatusUpdate(update) =&gt; {\n                if matches!(update.status.state, TaskState::Failed | TaskState::Rejected) {\n                    return Err(format!(\"Task failed: {:?}\", update.status.state).into());\n                }\n            }\n            _ =&gt; {}\n        }\n    }\n\n    Err(\"Task stream ended unexpectedly\".into())\n}\n</code></pre>"},{"location":"tasks/#next-steps","title":"Next Steps","text":"<ul> <li>Sessions Guide - Understand session-task relationships</li> </ul>"},{"location":"tools/","title":"Tools Guide","text":"<p>Tools in Radkit provide agents with the ability to perform actions beyond text generation. They enable function calling, state management, artifact creation, and interaction with external systems while maintaining security boundaries through the ToolContext system.</p>"},{"location":"tools/#understanding-the-tool-system","title":"Understanding the Tool System","text":""},{"location":"tools/#core-concepts","title":"Core Concepts","text":"<ul> <li>BaseTool: The fundamental trait that all tools must implement</li> <li>ToolContext: A secure, limited execution context that tools receive</li> <li>FunctionTool: A convenient wrapper for creating tools from async functions</li> <li>Toolset: Collections of tools that can be added to agents</li> <li>Built-in Tools: Pre-built tools for common agent operations</li> </ul>"},{"location":"tools/#tool-architecture","title":"Tool Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Agent       \u2502\u2500\u2500\u2500\u25b6\u2502  ExecutionContext\u2502\u2500\u2500\u2500\u25b6\u2502  EventProcessor \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                        \u2502                       \u2502\n         \u25bc                        \u25bc                       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Toolset      \u2502    \u2502   ToolContext    \u2502    \u2502 SessionService  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                        \u2502\n         \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   BaseTool      \u2502    \u2502 Capability Traits\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tools/#creating-custom-tools","title":"Creating Custom Tools","text":""},{"location":"tools/#using-functiontool-recommended","title":"Using FunctionTool (Recommended)","text":"<p>The <code>FunctionTool</code> wrapper is the easiest way to create tools:</p> <pre><code>use radkit::tools::{FunctionTool, ToolResult};\nuse serde_json::json;\n\nfn create_weather_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"get_weather\".to_string(),\n        \"Get current weather for a location\".to_string(),\n        |args, context| Box::pin(async move {\n            // Extract arguments\n            let location = args\n                .get(\"location\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"Unknown\");\n\n            // Check user preferences for temperature unit\n            let temp_unit = context\n                .get_user_state(\"temperature_unit\")\n                .await\n                .ok()\n                .flatten()\n                .and_then(|v| v.as_str().map(String::from))\n                .unwrap_or_else(|| \"fahrenheit\".to_string());\n\n            // Simulate weather API call\n            let temperature = if temp_unit == \"celsius\" { \"22\u00b0C\" } else { \"72\u00b0F\" };\n\n            let weather_data = json!({\n                \"location\": location,\n                \"temperature\": temperature,\n                \"conditions\": \"Partly cloudy\",\n                \"humidity\": \"45%\",\n                \"unit\": temp_unit\n            });\n\n            ToolResult::success(weather_data)\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"The city and state, e.g. San Francisco, CA\"\n            }\n        },\n        \"required\": [\"location\"]\n    }))\n}\n</code></pre>"},{"location":"tools/#state-aware-tools","title":"State-Aware Tools","text":"<p>Tools can read and modify user and session state:</p> <pre><code>fn create_settings_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"manage_settings\".to_string(),\n        \"Get or set user preferences\".to_string(),\n        |args, context| Box::pin(async move {\n            let action = args\n                .get(\"action\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"get\");\n\n            match action {\n                \"get\" =&gt; {\n                    // Read current settings\n                    let theme = context.get_user_state(\"theme\").await?;\n                    let language = context.get_user_state(\"language\").await?;\n\n                    ToolResult::success(json!({\n                        \"theme\": theme,\n                        \"language\": language\n                    }))\n                }\n                \"set\" =&gt; {\n                    // Update settings\n                    if let Some(theme) = args.get(\"theme\") {\n                        context.set_user_state(\"theme\".to_string(), theme.clone()).await?;\n                    }\n                    if let Some(language) = args.get(\"language\") {\n                        context.set_user_state(\"language\".to_string(), language.clone()).await?;\n                    }\n\n                    ToolResult::success(json!({\"message\": \"Settings updated\"}))\n                }\n                _ =&gt; ToolResult::error(\"Invalid action\".to_string())\n            }\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"action\": {\n                \"type\": \"string\",\n                \"enum\": [\"get\", \"set\"],\n                \"description\": \"Whether to get current settings or set new ones\"\n            },\n            \"theme\": {\n                \"type\": \"string\",\n                \"description\": \"Theme preference (when action=set)\"\n            },\n            \"language\": {\n                \"type\": \"string\", \n                \"description\": \"Language preference (when action=set)\"\n            }\n        },\n        \"required\": [\"action\"]\n    }))\n}\n</code></pre>"},{"location":"tools/#interactive-tools","title":"Interactive Tools","text":"<p>Tools can inject user input for interactive workflows:</p> <pre><code>fn create_confirmation_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"ask_confirmation\".to_string(),\n        \"Ask user for confirmation before proceeding\".to_string(),\n        |args, context| Box::pin(async move {\n            let question = args\n                .get(\"question\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"Are you sure?\");\n\n            // Create user input content for confirmation\n            let mut confirmation_content = radkit::models::content::Content::new(\n                context.task_id().to_string(),\n                context.context_id().to_string(),\n                uuid::Uuid::new_v4().to_string(),\n                MessageRole::User,\n            );\n\n            confirmation_content.add_text(\n                question.to_string(),\n                Some({\n                    let mut metadata = std::collections::HashMap::new();\n                    metadata.insert(\"interaction_type\".to_string(), json!(\"confirmation\"));\n                    metadata.insert(\"expects_response\".to_string(), json!(true));\n                    metadata\n                }),\n            );\n\n            context.add_user_input(confirmation_content).await?;\n\n            ToolResult::success(json!({\n                \"message\": \"Confirmation request sent to user\",\n                \"awaiting_response\": true\n            }))\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"question\": {\n                \"type\": \"string\",\n                \"description\": \"The confirmation question to ask\"\n            }\n        },\n        \"required\": [\"question\"]\n    }))\n}\n</code></pre>"},{"location":"tools/#long-running-tools","title":"Long-Running Tools","text":"<p>For tools that perform time-intensive operations:</p> <pre><code>fn create_data_processor() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"process_large_dataset\".to_string(),\n        \"Process a large dataset with progress updates\".to_string(),\n        |args, context| Box::pin(async move {\n            let dataset = args\n                .get(\"dataset\")\n                .and_then(|v| v.as_array())\n                .unwrap_or(&amp;vec![]);\n\n            // Update task status to working\n            context.update_task_status(\n                TaskState::Working,\n                Some(\"Starting data processing...\".to_string())\n            ).await?;\n\n            let total = dataset.len();\n            let mut processed = 0;\n\n            for (i, item) in dataset.iter().enumerate() {\n                // Simulate processing time\n                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n                processed += 1;\n\n                // Update progress every 10 items\n                if i % 10 == 0 {\n                    context.update_task_status(\n                        TaskState::Working,\n                        Some(format!(\"Processed {}/{} items\", processed, total))\n                    ).await?;\n                }\n            }\n\n            // Save results as artifact\n            let results = json!({\n                \"processed_count\": processed,\n                \"summary\": \"Dataset processing complete\",\n                \"timestamp\": chrono::Utc::now().to_rfc3339()\n            });\n\n            let artifact = Artifact {\n                artifact_id: format!(\"processing_results_{}\", uuid::Uuid::new_v4()),\n                parts: vec![Part::Text {\n                    text: results.to_string(),\n                    metadata: None,\n                }],\n                name: Some(\"Processing Results\".to_string()),\n                description: Some(\"Results from dataset processing\".to_string()),\n                extensions: vec![],\n                metadata: None,\n            };\n\n            context.save_artifact(artifact).await?;\n\n            // Mark task as completed\n            context.update_task_status(\n                TaskState::Completed,\n                Some(\"Data processing finished successfully\".to_string())\n            ).await?;\n\n            ToolResult::success(json!({\n                \"processed\": processed,\n                \"total\": total,\n                \"status\": \"completed\"\n            }))\n        }),\n    )\n    .with_long_running(true)  // Mark as long-running tool\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"dataset\": {\n                \"type\": \"array\",\n                \"description\": \"Array of data items to process\"\n            }\n        },\n        \"required\": [\"dataset\"]\n    }))\n}\n</code></pre>"},{"location":"tools/#implementing-basetool-directly","title":"Implementing BaseTool Directly","text":"<p>For advanced use cases, you can implement <code>BaseTool</code> directly:</p> <pre><code>use radkit::tools::{BaseTool, FunctionDeclaration, ToolResult, ToolContext};\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\npub struct CustomDatabaseTool {\n    connection_string: String,\n}\n\nimpl CustomDatabaseTool {\n    pub fn new(connection_string: String) -&gt; Self {\n        Self { connection_string }\n    }\n}\n\n#[async_trait]\nimpl BaseTool for CustomDatabaseTool {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"query_database\"\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Execute SQL queries against the database\"\n    }\n\n    fn is_long_running(&amp;self) -&gt; bool {\n        true\n    }\n\n    fn get_declaration(&amp;self) -&gt; Option&lt;FunctionDeclaration&gt; {\n        Some(FunctionDeclaration {\n            name: \"query_database\".to_string(),\n            description: \"Execute SQL queries against the database\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"SQL query to execute\"\n                    },\n                    \"limit\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Maximum number of rows to return\",\n                        \"default\": 100\n                    }\n                },\n                \"required\": [\"query\"]\n            })\n        })\n    }\n\n    async fn run_async(\n        &amp;self,\n        args: HashMap&lt;String, Value&gt;,\n        context: &amp;ToolContext&lt;'_&gt;,\n    ) -&gt; ToolResult {\n        let query = match args.get(\"query\").and_then(|v| v.as_str()) {\n            Some(q) =&gt; q,\n            None =&gt; return ToolResult::error(\"Query is required\".to_string()),\n        };\n\n        let limit = args.get(\"limit\")\n            .and_then(|v| v.as_u64())\n            .unwrap_or(100);\n\n        // Update status\n        context.update_task_status(\n            TaskState::Working,\n            Some(\"Executing database query...\".to_string())\n        ).await.ok();\n\n        // Simulate database query\n        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;\n\n        // Mock results\n        let results = json!({\n            \"query\": query,\n            \"rows\": [\n                {\"id\": 1, \"name\": \"John\", \"email\": \"john@example.com\"},\n                {\"id\": 2, \"name\": \"Jane\", \"email\": \"jane@example.com\"}\n            ],\n            \"count\": 2,\n            \"limit\": limit\n        });\n\n        // Save query results as artifact\n        let artifact = Artifact {\n            artifact_id: format!(\"query_results_{}\", uuid::Uuid::new_v4()),\n            parts: vec![Part::Text {\n                text: results.to_string(),\n                metadata: None,\n            }],\n            name: Some(\"Query Results\".to_string()),\n            description: Some(format!(\"Results for query: {}\", query)),\n            extensions: vec![],\n            metadata: None,\n        };\n\n        context.save_artifact(artifact).await.ok();\n\n        ToolResult::success(results)\n    }\n}\n</code></pre>"},{"location":"tools/#built-in-tools","title":"Built-in Tools","text":"<p>Radkit provides two essential built-in tools for task management:</p>"},{"location":"tools/#update_status-tool","title":"update_status Tool","text":"<p>Allows agents to control their task lifecycle:</p> <pre><code>// Enable built-in tools on your agent\nlet agent = Agent::builder(\n        \"You can use update_status to communicate your progress.\",\n        anthropic_llm,\n    )\n    .with_card(|c| c.with_name(\"task_agent\").with_description(\"Agent with task management\"))\n    .with_builtin_task_tools()\n    .build();\n\n// Agent can then use the tool:\n// {\"function_call\": {\"name\": \"update_status\", \"args\": {\"status\": \"working\", \"message\": \"Processing data...\"}}}\n</code></pre> <p>Available status values: - <code>\"submitted\"</code> - Initial state - <code>\"working\"</code> - Agent is processing - <code>\"input_required\"</code> - Need user input - <code>\"auth_required\"</code> - Need authentication - <code>\"completed\"</code> - Task finished successfully - <code>\"failed\"</code> - Task failed due to error - <code>\"rejected\"</code> - Task was rejected - <code>\"canceled\"</code> - Task was canceled</p>"},{"location":"tools/#save_artifact-tool","title":"save_artifact Tool","text":"<p>Allows agents to persist important outputs:</p> <pre><code>// Agent can use this tool:\n// {\n//   \"function_call\": {\n//     \"name\": \"save_artifact\",\n//     \"args\": {\n//       \"name\": \"Analysis Report\",\n//       \"content\": \"...\",\n//       \"type\": \"document\", \n//       \"description\": \"Complete analysis results\"\n//     }\n//   }\n// }\n</code></pre> <p>Supported artifact types: - <code>\"file\"</code> - File content - <code>\"data\"</code> - Structured data - <code>\"result\"</code> - Computation results - <code>\"log\"</code> - Log entries - <code>\"image\"</code> - Image data - <code>\"document\"</code> - Text documents</p>"},{"location":"tools/#toolsets","title":"Toolsets","text":"<p>Organize tools into reusable collections:</p>"},{"location":"tools/#simpletoolset","title":"SimpleToolset","text":"<pre><code>use radkit::tools::SimpleToolset;\n\nlet weather_tool = create_weather_tool();\nlet calculator_tool = create_calculator_tool();\n\nlet toolset = SimpleToolset::new()\n    .add_tool(weather_tool)\n    .add_tool(calculator_tool);\n\n// Add to agent\nlet agent = Agent::builder(\n        \"You have access to weather and calculator tools.\",\n        anthropic_llm,\n    )\n    .with_card(|c| c.with_name(\"multi_tool_agent\").with_description(\"Agent with multiple tools\"))\n    .with_toolset(toolset)\n    .build();\n</code></pre>"},{"location":"tools/#combinedtoolset","title":"CombinedToolset","text":"<p>Merge multiple toolsets:</p> <pre><code>use radkit::tools::CombinedToolset;\n\nlet base_toolset = create_base_toolset();\nlet specialized_toolset = create_domain_specific_toolset();\n\nlet combined = CombinedToolset::new(base_toolset)\n    .with_additional_toolset(specialized_toolset);\n\nlet agent = Agent::builder(\n        \"You have access to multiple toolsets.\",\n        anthropic_llm,\n    )\n    .with_toolset(combined)\n    .build();\n</code></pre>"},{"location":"tools/#error-handling-in-tools","title":"Error Handling in Tools","text":""},{"location":"tools/#graceful-error-handling","title":"Graceful Error Handling","text":"<pre><code>fn create_robust_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"robust_operation\".to_string()).with_description(\"An operation that handles errors gracefully\".to_string()))\n    .build().await {\n                Ok(result) =&gt; {\n                    context.update_task_status(\n                        TaskState::Completed,\n                        Some(\"Operation completed successfully\".to_string())\n                    ).await.ok();\n\n                    ToolResult::success(result)\n                }\n                Err(e) =&gt; {\n                    // Update task status to indicate failure\n                    context.update_task_status(\n                        TaskState::Working, // Continue working, don't fail task\n                        Some(format!(\"Operation failed: {}\", e))\n                    ).await.ok();\n\n                    // Return error to agent\n                    ToolResult::error(format!(\"Failed to complete operation: {}\", e))\n                }\n            }\n        }),\n    )\n}\n\nasync fn perform_risky_operation(args: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;Value, String&gt; {\n    // Simulate operation that might fail\n    if args.get(\"should_fail\").and_then(|v| v.as_bool()).unwrap_or(false) {\n        Err(\"Simulated failure\".to_string())\n    } else {\n        Ok(json!({\"success\": true}))\n    }\n}\n</code></pre>"},{"location":"tools/#retry-logic","title":"Retry Logic","text":"<pre><code>fn create_retry_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"retry_operation\".to_string(),\n        \"Operation with automatic retry logic\".to_string(),\n        |args, context| Box::pin(async move {\n            let max_retries = 3;\n\n            for attempt in 1..=max_retries {\n                context.update_task_status(\n                    TaskState::Working,\n                    Some(format!(\"Attempt {} of {}\", attempt, max_retries))\n                ).await.ok();\n\n                match perform_unreliable_operation(&amp;args).await {\n                    Ok(result) =&gt; {\n                        return ToolResult::success(result);\n                    }\n                    Err(e) if attempt == max_retries =&gt; {\n                        return ToolResult::error(format!(\n                            \"Failed after {} attempts: {}\", max_retries, e\n                        ));\n                    }\n                    Err(_) =&gt; {\n                        // Wait before retry\n                        tokio::time::sleep(\n                            tokio::time::Duration::from_millis(1000 * attempt)\n                        ).await;\n                    }\n                }\n            }\n\n            unreachable!()\n        }),\n    )\n}\n\nasync fn perform_unreliable_operation(args: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;Value, String&gt; {\n    // Simulate unreliable operation\n    use rand::Rng;\n    let mut rng = rand::thread_rng();\n\n    if rng.gen_bool(0.7) { // 70% chance of failure\n        Err(\"Network timeout\".to_string())\n    } else {\n        Ok(json!({\"data\": \"success\"}))\n    }\n}\n</code></pre>"},{"location":"tools/#testing-tools","title":"Testing Tools","text":""},{"location":"tools/#unit-testing","title":"Unit Testing","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use radkit::tools::ToolContext;\n    use radkit::events::{ExecutionContext, EventProcessor, InMemoryEventBus};\n    use radkit::sessions::{InMemorySessionService, QueryService};\n    use std::sync::Arc;\n\n    async fn create_test_context() -&gt; ExecutionContext {\n        let session_service = Arc::new(InMemorySessionService::new());\n        let query_service = Arc::new(QueryService::new(session_service.clone()));\n        let event_bus = Arc::new(InMemoryEventBus::new());\n        let event_processor = Arc::new(EventProcessor::new(session_service, event_bus));\n\n        // Create execution context for testing\n        ExecutionContext::new(\n            \"test_ctx\".to_string(),\n            \"test_task\".to_string(),\n            \"test_app\".to_string(),\n            \"test_user\".to_string(),\n            params, // MessageSendParams\n            event_processor,\n            query_service,\n        )\n    }\n\n    #[tokio::test]\n    async fn test_weather_tool() {\n        let tool = create_weather_tool();\n        let exec_ctx = create_test_context().await;\n        let tool_ctx = ToolContext::from_execution_context(&amp;exec_ctx);\n\n        let mut args = HashMap::new();\n        args.insert(\"location\".to_string(), json!(\"San Francisco, CA\"));\n\n        let result = tool.run_async(args, &amp;tool_ctx).await;\n\n        assert!(result.success);\n        assert!(result.data.get(\"location\").is_some());\n        assert!(result.data.get(\"temperature\").is_some());\n    }\n\n    #[tokio::test]\n    async fn test_settings_tool_state_management() {\n        let tool = create_settings_tool();\n        let exec_ctx = create_test_context().await;\n        let tool_ctx = ToolContext::from_execution_context(&amp;exec_ctx);\n\n        // Set a preference\n        let mut args = HashMap::new();\n        args.insert(\"action\".to_string(), json!(\"set\"));\n        args.insert(\"theme\".to_string(), json!(\"dark\"));\n\n        let result = tool.run_async(args, &amp;tool_ctx).await;\n        assert!(result.success);\n\n        // Get preferences\n        let mut args = HashMap::new();\n        args.insert(\"action\".to_string(), json!(\"get\"));\n\n        let result = tool.run_async(args, &amp;tool_ctx).await;\n        assert!(result.success);\n        assert_eq!(result.data[\"theme\"], json!(\"dark\"));\n    }\n}\n</code></pre>"},{"location":"tools/#best-practices","title":"Best Practices","text":""},{"location":"tools/#1-use-descriptive-names-and-documentation","title":"1. Use Descriptive Names and Documentation","text":"<pre><code>fn create_well_documented_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"analyze_sentiment\".to_string(),\n        \"Analyze the emotional sentiment of text using natural language processing. Returns sentiment score (-1.0 to 1.0) and confidence level.\".to_string(),\n        |args, context| {\n            // Implementation\n        },\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"text\": {\n                \"type\": \"string\",\n                \"description\": \"The text to analyze for sentiment\",\n                \"minLength\": 1,\n                \"maxLength\": 5000\n            },\n            \"model\": {\n                \"type\": \"string\", \n                \"enum\": [\"basic\", \"advanced\"],\n                \"default\": \"basic\",\n                \"description\": \"Sentiment analysis model to use\"\n            }\n        },\n        \"required\": [\"text\"]\n    }))\n}\n</code></pre>"},{"location":"tools/#2-handle-context-information","title":"2. Handle Context Information","text":"<pre><code>fn create_context_aware_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"context_aware_operation\".to_string(),\n        \"Operation that uses context information\".to_string(),\n        |args, context| Box::pin(async move {\n            // Access context information\n            let task_id = context.task_id();\n            let user_id = context.user_id();\n            let app_name = context.app_name();\n\n            // Use context in operation\n            let result = json!({\n                \"result\": \"operation completed\",\n                \"context\": {\n                    \"task_id\": task_id,\n                    \"user_id\": user_id,\n                    \"app_name\": app_name\n                }\n            });\n\n            ToolResult::success(result)\n        }),\n    )\n}\n</code></pre>"},{"location":"tools/#3-implement-proper-validation","title":"3. Implement Proper Validation","text":"<pre><code>fn create_validated_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"send_email\".to_string(),\n        \"Send an email to specified recipients\".to_string(),\n        |args, context| Box::pin(async move {\n            // Validate required parameters\n            let to = match args.get(\"to\").and_then(|v| v.as_str()) {\n                Some(email) if is_valid_email(email) =&gt; email,\n                Some(invalid) =&gt; return ToolResult::error(\n                    format!(\"Invalid email address: {}\", invalid)\n                ),\n                None =&gt; return ToolResult::error(\"to field is required\".to_string()),\n            };\n\n            let subject = args.get(\"subject\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"(No Subject)\");\n\n            let body = match args.get(\"body\").and_then(|v| v.as_str()) {\n                Some(b) if !b.trim().is_empty() =&gt; b,\n                _ =&gt; return ToolResult::error(\"body cannot be empty\".to_string()),\n            };\n\n            // Perform operation\n            send_email_impl(to, subject, body).await\n        }),\n    )\n    .with_parameters_schema(json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\n                \"type\": \"string\",\n                \"format\": \"email\",\n                \"description\": \"Recipient email address\"\n            },\n            \"subject\": {\n                \"type\": \"string\",\n                \"maxLength\": 200,\n                \"description\": \"Email subject line\"\n            },\n            \"body\": {\n                \"type\": \"string\",\n                \"minLength\": 1,\n                \"maxLength\": 10000,\n                \"description\": \"Email message body\"\n            }\n        },\n        \"required\": [\"to\", \"body\"]\n    }))\n}\n\nfn is_valid_email(email: &amp;str) -&gt; bool {\n    // Basic email validation\n    email.contains('@') &amp;&amp; email.contains('.')\n}\n\nasync fn send_email_impl(to: &amp;str, subject: &amp;str, body: &amp;str) -&gt; ToolResult {\n    // Implement email sending\n    ToolResult::success(json!({\"sent\": true, \"to\": to}))\n}\n</code></pre>"},{"location":"tools/#4-provide-progress-updates","title":"4. Provide Progress Updates","text":"<pre><code>fn create_progress_tool() -&gt; FunctionTool {\n    FunctionTool::new(\n        \"batch_process\".to_string(),\n        \"Process multiple items with progress updates\".to_string(),\n        |args, context| Box::pin(async move {\n            let items = match args.get(\"items\").and_then(|v| v.as_array()) {\n                Some(items) =&gt; items,\n                None =&gt; return ToolResult::error(\"items array is required\".to_string()),\n            };\n\n            let total = items.len();\n            let mut processed = Vec::new();\n\n            for (index, item) in items.iter().enumerate() {\n                // Update progress\n                let progress = ((index as f64 / total as f64) * 100.0) as u32;\n                context.update_task_status(\n                    TaskState::Working,\n                    Some(format!(\"Processing item {} of {} ({}%)\", \n                        index + 1, total, progress))\n                ).await.ok();\n\n                // Process item\n                let result = process_item(item).await?;\n                processed.push(result);\n\n                // Small delay to show progress\n                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n            }\n\n            ToolResult::success(json!({\n                \"processed\": processed,\n                \"total\": total\n            }))\n        }),\n    )\n    .with_long_running(true)\n}\n</code></pre>"},{"location":"tools/#mcp-model-context-protocol-tools","title":"MCP (Model Context Protocol) Tools","text":"<p>Radkit includes built-in support for MCP servers, which provide external tools and data sources for agents. MCP tools are automatically discovered and integrated into your agent's toolset.</p>"},{"location":"tools/#setting-up-mcp-weather-agent","title":"Setting Up MCP Weather Agent","text":"<p>Here's a complete example of creating an agent that uses an MCP weather server:</p> <pre><code>use radkit::agents::Agent;\nuse radkit::models::AnthropicLlm;\nuse radkit::sessions::InMemorySessionService;\nuse radkit::tools::{MCPConnectionParams, MCPToolset};\nuse radkit::a2a::{Message, MessageSendParams, Part};\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse tokio_stream::StreamExt;\n\nasync fn create_weather_agent() -&gt; Agent {\n    // Create LLM (Anthropic Claude in this example)\n    let llm = AnthropicLlm::new(\n        \"claude-3-5-sonnet-20241022\".to_string(),\n        std::env::var(\"ANTHROPIC_API_KEY\").expect(\"ANTHROPIC_API_KEY required\")\n    );\n\n    // Create session service\n    let session_service = InMemorySessionService::new();\n\n    // Configure MCP weather server connection\n    let mcp_connection = MCPConnectionParams::Stdio {\n        command: \"uvx\".to_string(),\n        args: vec![\n            \"--from\".to_string(),\n            \"git+https://github.com/microagents/mcp-servers.git#subdirectory=mcp-weather-free\".to_string(),\n            \"mcp-weather-free\".to_string(),\n        ],\n        env: HashMap::new(),\n        timeout: Duration::from_secs(30),\n    };\n\n    // Create MCP toolset\n    let mcp_toolset = MCPToolset::new(mcp_connection);\n\n    // Build weather agent with MCP tools\n    Agent::builder(\n        \"You are a helpful weather assistant. Use the available weather tools to provide accurate weather information for any location requested by the user. Always call the weather tools when users ask about weather conditions, forecasts, or climate information.\",\n        llm,\n    )\n    .with_card(|c| c.with_name(\"weather_agent\").with_description(\"Weather Assistant\"))\n    .with_session_service(session_service)\n    .with_toolset(mcp_toolset)\n    .with_builtin_task_tools() // Include update_status and save_artifact tools\n    .build()\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create the weather agent\n    let agent = create_weather_agent().await;\n\n    // Create user message asking for weather\n    let user_message = Message {\n        kind: \"message\".to_string(),\n        message_id: uuid::Uuid::new_v4().to_string(),\n        role: radkit::a2a::MessageRole::User,\n        parts: vec![Part::Text {\n            text: \"What's the current weather in San Francisco, California?\".to_string(),\n            metadata: None,\n        }],\n        context_id: None,\n        task_id: None,\n        reference_task_ids: vec![],\n        extensions: vec![],\n        metadata: None,\n    };\n\n    // Send message and get streaming response\n    let params = MessageSendParams {\n        message: user_message,\n        configuration: None,\n        metadata: None,\n    };\n\n    let mut execution = agent\n        .send_streaming_message(\n            \"weather_app\".to_string(),\n            \"user_123\".to_string(),\n            params,\n        )\n        .await?;\n\n    // Process streaming response\n    println!(\"\ud83c\udf24\ufe0f Weather Assistant Response:\");\n    while let Some(result) = execution.a2a_stream.next().await {\n        match result {\n            radkit::a2a::SendStreamingMessageResult::Message(message) =&gt; {\n                for part in &amp;message.parts {\n                    if let Part::Text { text, .. } = part {\n                        print!(\"{}\", text);\n                    }\n                }\n            }\n            radkit::a2a::SendStreamingMessageResult::Task(task) =&gt; {\n                println!(\"\\n\u2705 Task completed: {:?}\", task.status.state);\n                break;\n            }\n            _ =&gt; {}\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"tools/#mcp-connection-types","title":"MCP Connection Types","text":"<p>The <code>MCPConnectionParams</code> enum supports different MCP server connection methods:</p>"},{"location":"tools/#stdio-connection-local-process","title":"Stdio Connection (Local Process)","text":"<pre><code>use radkit::tools::MCPConnectionParams;\nuse std::time::Duration;\nuse std::collections::HashMap;\n\nlet stdio_connection = MCPConnectionParams::Stdio {\n    command: \"python\".to_string(),\n    args: vec![\"-m\".to_string(), \"my_mcp_server\".to_string()],\n    env: {\n        let mut env = HashMap::new();\n        env.insert(\"API_KEY\".to_string(), \"your_api_key\".to_string());\n        env\n    },\n    timeout: Duration::from_secs(30),\n};\n</code></pre>"},{"location":"tools/#http-connection-remote-server","title":"HTTP Connection (Remote Server)","text":"<pre><code>let http_connection = MCPConnectionParams::Http {\n    url: \"https://api.example.com/mcp\".to_string(),\n    headers: {\n        let mut headers = HashMap::new();\n        headers.insert(\"Authorization\".to_string(), \"Bearer token\".to_string());\n        headers.insert(\"Content-Type\".to_string(), \"application/json\".to_string());\n        headers\n    },\n    timeout: Duration::from_secs(10),\n};\n</code></pre>"},{"location":"tools/#tool-filtering","title":"Tool Filtering","text":"<p>You can control which MCP tools are available to your agent:</p> <pre><code>use radkit::tools::{MCPToolset, MCPToolFilter};\n\n// Include all tools (default)\nlet all_tools = MCPToolset::new(mcp_connection)\n    .with_tool_filter(MCPToolFilter::All);\n\n// Include only specific tools\nlet specific_tools = MCPToolset::new(mcp_connection)\n    .with_tool_filter(MCPToolFilter::Include(vec![\n        \"get_weather\".to_string(),\n        \"get_forecast\".to_string(),\n    ]));\n\n// Exclude certain tools\nlet filtered_tools = MCPToolset::new(mcp_connection)\n    .with_tool_filter(MCPToolFilter::Exclude(vec![\n        \"dangerous_tool\".to_string(),\n    ]));\n</code></pre>"},{"location":"tools/#multiple-mcp-servers","title":"Multiple MCP Servers","text":"<p>You can combine multiple MCP toolsets for different capabilities:</p> <pre><code>use radkit::tools::{CombinedToolset, SimpleToolset};\n\nasync fn create_multi_capability_agent() -&gt; Agent {\n    // Weather MCP server\n    let weather_connection = MCPConnectionParams::Stdio {\n        command: \"uvx\".to_string(),\n        args: vec![\"--from\".to_string(), \"mcp-weather\".to_string(), \"mcp-weather\".to_string()],\n        env: HashMap::new(),\n        timeout: Duration::from_secs(30),\n    };\n    let weather_toolset = MCPToolset::new(weather_connection);\n\n    // Database MCP server\n    let db_connection = MCPConnectionParams::Http {\n        url: \"https://db-mcp.example.com\".to_string(),\n        headers: {\n            let mut headers = HashMap::new();\n            headers.insert(\"Authorization\".to_string(), \"Bearer db_token\".to_string());\n            headers\n        },\n        timeout: Duration::from_secs(15),\n    };\n    let db_toolset = MCPToolset::new(db_connection);\n\n    // Custom tools\n    let custom_toolset = SimpleToolset::new()\n        .add_tool(create_calculator_tool());\n\n    // Combine all toolsets\n    let combined_toolset = CombinedToolset::new(weather_toolset)\n        .with_additional_toolset(db_toolset)\n        .with_additional_toolset(custom_toolset);\n\n    Agent::builder(\n        \"You have access to weather data, database queries, and calculation tools.\",\n        llm,\n    )\n    .with_card(|c| c.with_name(\"multi_agent\").with_description(\"Multi-Capability Assistant\"))\n    .with_toolset(combined_toolset)\n    .build()\n}\n</code></pre>"},{"location":"tools/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide - Learn basic agent setup</li> <li>Tasks Guide - Understand task lifecycle</li> <li>Sessions Guide - Learn about state management</li> </ul> <p>The tools system in Radkit provides a powerful foundation for extending agent capabilities while maintaining security and reliability. Use the ToolContext system to create safe, capable tools that integrate seamlessly with the A2A protocol.</p>"}]}